# DataSophon API 拦截器详解

## 一、拦截器概述

### 1.1 拦截器架构

DataSophon API 采用多层拦截器架构，实现请求的统一处理和增强功能：

```
HTTP 请求
    ↓
┌─────────────────────────────────┐
│   1. CorsInterceptor            │ 跨域处理
├─────────────────────────────────┤
│   2. LogInterceptor              │ 请求日志
├─────────────────────────────────┤
│   3. AuthenticationInterceptor   │ 身份认证
├─────────────────────────────────┤
│   4. PermissionInterceptor       │ 权限验证
├─────────────────────────────────┤
│   5. TenantInterceptor           │ 租户隔离
├─────────────────────────────────┤
│   6. RateLimitInterceptor        │ 请求限流
└─────────────────────────────────┘
    ↓
Controller 处理
    ↓
┌─────────────────────────────────┐
│   7. ResponseWrapperInterceptor  │ 响应包装
└─────────────────────────────────┘
    ↓
HTTP 响应
```

### 1.2 拦截器配置

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Autowired
    private CorsInterceptor corsInterceptor;
    
    @Autowired
    private LogInterceptor logInterceptor;
    
    @Autowired
    private AuthenticationInterceptor authenticationInterceptor;
    
    @Autowired
    private PermissionInterceptor permissionInterceptor;
    
    @Autowired
    private TenantInterceptor tenantInterceptor;
    
    @Autowired
    private RateLimitInterceptor rateLimitInterceptor;
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 1. CORS 跨域拦截器（最先执行）
        registry.addInterceptor(corsInterceptor)
            .addPathPatterns("/**")
            .order(1);
        
        // 2. 日志拦截器
        registry.addInterceptor(logInterceptor)
            .addPathPatterns("/api/**")
            .order(2);
        
        // 3. 认证拦截器
        registry.addInterceptor(authenticationInterceptor)
            .addPathPatterns("/api/**")
            .excludePathPatterns(
                "/api/login/**",
                "/api/captcha/**",
                "/actuator/**"
            )
            .order(3);
        
        // 4. 权限拦截器
        registry.addInterceptor(permissionInterceptor)
            .addPathPatterns("/api/**")
            .excludePathPatterns("/api/login/**")
            .order(4);
        
        // 5. 租户拦截器
        registry.addInterceptor(tenantInterceptor)
            .addPathPatterns("/api/**")
            .order(5);
        
        // 6. 限流拦截器
        registry.addInterceptor(rateLimitInterceptor)
            .addPathPatterns("/api/**")
            .order(6);
    }
}
```

## 二、核心拦截器详解

### 2.1 CORS 跨域拦截器

#### 2.1.1 基本实现

```java
@Component
public class CorsInterceptor implements HandlerInterceptor {
    
    @Value("${cors.allowed-origins:*}")
    private String allowedOrigins;
    
    @Value("${cors.allowed-methods:GET,POST,PUT,DELETE,OPTIONS}")
    private String allowedMethods;
    
    @Value("${cors.allowed-headers:*}")
    private String allowedHeaders;
    
    @Value("${cors.max-age:3600}")
    private Long maxAge;
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        // 设置 CORS 响应头
        String origin = request.getHeader("Origin");
        if (isAllowedOrigin(origin)) {
            response.setHeader("Access-Control-Allow-Origin", origin);
        }
        
        response.setHeader("Access-Control-Allow-Methods", allowedMethods);
        response.setHeader("Access-Control-Allow-Headers", allowedHeaders);
        response.setHeader("Access-Control-Max-Age", String.valueOf(maxAge));
        response.setHeader("Access-Control-Allow-Credentials", "true");
        
        // OPTIONS 预检请求直接返回
        if ("OPTIONS".equals(request.getMethod())) {
            response.setStatus(HttpServletResponse.SC_OK);
            return false;
        }
        
        return true;
    }
    
    /**
     * 检查源是否允许
     */
    private boolean isAllowedOrigin(String origin) {
        if (origin == null) {
            return false;
        }
        
        if ("*".equals(allowedOrigins)) {
            return true;
        }
        
        String[] origins = allowedOrigins.split(",");
        return Arrays.asList(origins).contains(origin);
    }
}
```

#### 2.1.2 配置示例

```yaml
# application.yml
cors:
  allowed-origins: http://localhost:3000,https://datasophon.example.com
  allowed-methods: GET,POST,PUT,DELETE,OPTIONS
  allowed-headers: Content-Type,Authorization,X-Requested-With
  max-age: 3600
```

### 2.2 日志拦截器

#### 2.2.1 请求日志记录

```java
@Component
@Slf4j
public class LogInterceptor implements HandlerInterceptor {
    
    private static final String START_TIME_ATTR = "startTime";
    private static final String REQUEST_ID_ATTR = "requestId";
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        // 生成请求 ID
        String requestId = UUID.randomUUID().toString().replace("-", "");
        request.setAttribute(REQUEST_ID_ATTR, requestId);
        
        // 记录开始时间
        long startTime = System.currentTimeMillis();
        request.setAttribute(START_TIME_ATTR, startTime);
        
        // 记录请求信息
        logRequest(request, requestId);
        
        return true;
    }
    
    @Override
    public void postHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        ModelAndView modelAndView
    ) throws Exception {
        // Controller 执行完成
    }
    
    @Override
    public void afterCompletion(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        Exception ex
    ) throws Exception {
        
        // 计算执行时间
        long startTime = (Long) request.getAttribute(START_TIME_ATTR);
        long executionTime = System.currentTimeMillis() - startTime;
        
        // 记录响应信息
        logResponse(request, response, executionTime, ex);
    }
    
    /**
     * 记录请求信息
     */
    private void logRequest(HttpServletRequest request, String requestId) {
        String method = request.getMethod();
        String uri = request.getRequestURI();
        String queryString = request.getQueryString();
        String clientIp = getClientIp(request);
        String userAgent = request.getHeader("User-Agent");
        
        log.info("==> [{}] {} {} {} from {} ({})",
            requestId,
            method,
            uri,
            queryString != null ? "?" + queryString : "",
            clientIp,
            userAgent
        );
        
        // 记录请求参数
        if (!"GET".equals(method)) {
            Map<String, String[]> paramMap = request.getParameterMap();
            if (!paramMap.isEmpty()) {
                log.info("Request params: {}", JsonUtils.toJson(paramMap));
            }
        }
    }
    
    /**
     * 记录响应信息
     */
    private void logResponse(
        HttpServletRequest request,
        HttpServletResponse response,
        long executionTime,
        Exception ex
    ) {
        String requestId = (String) request.getAttribute(REQUEST_ID_ATTR);
        int status = response.getStatus();
        
        if (ex != null) {
            log.error("<== [{}] {} {} ms (ERROR: {})",
                requestId,
                status,
                executionTime,
                ex.getMessage()
            );
        } else {
            log.info("<== [{}] {} {} ms",
                requestId,
                status,
                executionTime
            );
        }
        
        // 慢请求告警（超过 3 秒）
        if (executionTime > 3000) {
            log.warn("Slow request detected: [{}] {} took {} ms",
                requestId,
                request.getRequestURI(),
                executionTime
            );
        }
    }
    
    /**
     * 获取客户端真实 IP
     */
    private String getClientIp(HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("X-Real-IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        // 处理多个代理的情况
        if (ip != null && ip.contains(",")) {
            ip = ip.split(",")[0].trim();
        }
        return ip;
    }
}
```

#### 2.2.2 日志输出示例

```
2025-11-16 10:30:15.123 INFO  ==> [a1b2c3d4] POST /api/cluster/save  from 192.168.1.100 (Mozilla/5.0...)
2025-11-16 10:30:15.125 INFO  Request params: {"clusterName":"test-cluster","clusterCode":"tc01"}
2025-11-16 10:30:15.456 INFO  <== [a1b2c3d4] 200 333 ms
```

### 2.3 认证拦截器

详见 [10-安全认证.md](./10-安全认证.md) 中的 AuthenticationInterceptor。

### 2.4 权限拦截器

```java
@Component
public class PermissionInterceptor implements HandlerInterceptor {
    
    @Autowired
    private PermissionService permissionService;
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        // 只处理方法处理器
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        
        // 检查方法上的权限注解
        RequiresPermissions annotation = handlerMethod.getMethodAnnotation(RequiresPermissions.class);
        if (annotation == null) {
            // 检查类上的权限注解
            annotation = handlerMethod.getBeanType().getAnnotation(RequiresPermissions.class);
        }
        
        // 没有权限注解，放行
        if (annotation == null) {
            return true;
        }
        
        // 获取当前用户
        Integer userId = UserContext.getCurrentUserId();
        if (userId == null) {
            sendForbiddenResponse(response, "用户未登录");
            return false;
        }
        
        // 验证权限
        String[] permissions = annotation.value();
        Logical logical = annotation.logical();
        
        boolean hasPermission;
        if (logical == Logical.AND) {
            hasPermission = permissionService.hasAllPermissions(userId, permissions);
        } else {
            hasPermission = permissionService.hasAnyPermission(userId, permissions);
        }
        
        if (!hasPermission) {
            sendForbiddenResponse(response, "权限不足");
            return false;
        }
        
        return true;
    }
    
    private void sendForbiddenResponse(HttpServletResponse response, String message) 
        throws IOException {
        
        response.setStatus(HttpServletResponse.SC_FORBIDDEN);
        response.setContentType("application/json;charset=UTF-8");
        
        Result result = Result.error(403, message);
        response.getWriter().write(JsonUtils.toJson(result));
    }
}
```

### 2.5 租户拦截器

```java
@Component
public class TenantInterceptor implements HandlerInterceptor {
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        // 获取租户 ID（从请求头或参数）
        String tenantId = getTenantId(request);
        
        if (StringUtils.isNotEmpty(tenantId)) {
            // 设置租户上下文
            TenantContext.setTenantId(tenantId);
            
            // 记录日志
            log.debug("Tenant context set: {}", tenantId);
        }
        
        return true;
    }
    
    @Override
    public void afterCompletion(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        Exception ex
    ) throws Exception {
        // 清理租户上下文
        TenantContext.clear();
    }
    
    /**
     * 获取租户 ID
     */
    private String getTenantId(HttpServletRequest request) {
        // 1. 从 Header 获取
        String tenantId = request.getHeader("X-Tenant-Id");
        if (StringUtils.isNotEmpty(tenantId)) {
            return tenantId;
        }
        
        // 2. 从参数获取
        tenantId = request.getParameter("tenantId");
        if (StringUtils.isNotEmpty(tenantId)) {
            return tenantId;
        }
        
        // 3. 从当前用户获取
        Integer userId = UserContext.getCurrentUserId();
        if (userId != null) {
            UserInfoEntity user = userInfoService.getById(userId);
            if (user != null) {
                return user.getTenantId();
            }
        }
        
        return null;
    }
}

/**
 * 租户上下文
 */
public class TenantContext {
    
    private static final ThreadLocal<String> TENANT_HOLDER = new ThreadLocal<>();
    
    public static void setTenantId(String tenantId) {
        TENANT_HOLDER.set(tenantId);
    }
    
    public static String getTenantId() {
        return TENANT_HOLDER.get();
    }
    
    public static void clear() {
        TENANT_HOLDER.remove();
    }
}
```

### 2.6 限流拦截器

```java
@Component
@Slf4j
public class RateLimitInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisTemplate<String, Long> redisTemplate;
    
    @Value("${rate-limit.enabled:true}")
    private boolean enabled;
    
    @Value("${rate-limit.default-limit:100}")
    private int defaultLimit;
    
    @Value("${rate-limit.period:60}")
    private int period;
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        if (!enabled) {
            return true;
        }
        
        // 只处理方法处理器
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        
        // 检查方法上的限流注解
        RateLimit annotation = handlerMethod.getMethodAnnotation(RateLimit.class);
        
        int limit = annotation != null ? annotation.count() : defaultLimit;
        int periodSeconds = annotation != null ? annotation.period() : period;
        
        // 构建限流键
        String key = buildRateLimitKey(request, handlerMethod);
        
        // 检查是否超过限流
        if (isRateLimitExceeded(key, limit, periodSeconds)) {
            sendRateLimitResponse(response);
            return false;
        }
        
        return true;
    }
    
    /**
     * 构建限流键
     */
    private String buildRateLimitKey(HttpServletRequest request, HandlerMethod handler) {
        Integer userId = UserContext.getCurrentUserId();
        String uri = request.getRequestURI();
        String method = handler.getMethod().getName();
        
        if (userId != null) {
            // 基于用户的限流
            return String.format("rate:limit:user:%d:%s:%s", userId, uri, method);
        } else {
            // 基于 IP 的限流
            String clientIp = getClientIp(request);
            return String.format("rate:limit:ip:%s:%s:%s", clientIp, uri, method);
        }
    }
    
    /**
     * 检查是否超过限流
     */
    private boolean isRateLimitExceeded(String key, int limit, int period) {
        Long count = redisTemplate.opsForValue().get(key);
        
        if (count == null) {
            // 首次请求，设置计数为 1
            redisTemplate.opsForValue().set(key, 1L, period, TimeUnit.SECONDS);
            return false;
        }
        
        if (count >= limit) {
            // 超过限流
            log.warn("Rate limit exceeded: key={}, count={}, limit={}", key, count, limit);
            return true;
        }
        
        // 增加计数
        redisTemplate.opsForValue().increment(key);
        return false;
    }
    
    /**
     * 发送限流响应
     */
    private void sendRateLimitResponse(HttpServletResponse response) throws IOException {
        response.setStatus(429); // Too Many Requests
        response.setContentType("application/json;charset=UTF-8");
        
        Result result = Result.error(429, "请求过于频繁，请稍后再试");
        response.getWriter().write(JsonUtils.toJson(result));
    }
    
    private String getClientIp(HttpServletRequest request) {
        String ip = request.getHeader("X-Forwarded-For");
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("X-Real-IP");
        }
        if (ip == null || ip.isEmpty() || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();
        }
        if (ip != null && ip.contains(",")) {
            ip = ip.split(",")[0].trim();
        }
        return ip;
    }
}
```

### 2.7 响应包装拦截器

```java
@Component
public class ResponseWrapperInterceptor implements HandlerInterceptor {
    
    @Override
    public void postHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        ModelAndView modelAndView
    ) throws Exception {
        
        // 添加响应头
        response.setHeader("X-Content-Type-Options", "nosniff");
        response.setHeader("X-Frame-Options", "DENY");
        response.setHeader("X-XSS-Protection", "1; mode=block");
        response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
        response.setHeader("Pragma", "no-cache");
        response.setHeader("Expires", "0");
        
        // 添加请求 ID
        String requestId = (String) request.getAttribute("requestId");
        if (requestId != null) {
            response.setHeader("X-Request-Id", requestId);
        }
    }
}
```

## 三、高级拦截器

### 3.1 幂等性拦截器

```java
@Component
public class IdempotentInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String IDEMPOTENT_KEY_PREFIX = "idempotent:";
    private static final long IDEMPOTENT_EXPIRE_TIME = 3600; // 1 小时
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        
        // 检查方法上的幂等性注解
        Idempotent annotation = handlerMethod.getMethodAnnotation(Idempotent.class);
        if (annotation == null) {
            return true;
        }
        
        // 获取幂等性 Token
        String token = request.getHeader("X-Idempotent-Token");
        if (StringUtils.isEmpty(token)) {
            sendErrorResponse(response, "缺少幂等性 Token");
            return false;
        }
        
        // 检查 Token 是否已使用
        String key = IDEMPOTENT_KEY_PREFIX + token;
        Boolean success = redisTemplate.opsForValue().setIfAbsent(
            key,
            "1",
            IDEMPOTENT_EXPIRE_TIME,
            TimeUnit.SECONDS
        );
        
        if (Boolean.FALSE.equals(success)) {
            sendErrorResponse(response, "请勿重复提交");
            return false;
        }
        
        return true;
    }
    
    private void sendErrorResponse(HttpServletResponse response, String message) 
        throws IOException {
        
        response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
        response.setContentType("application/json;charset=UTF-8");
        
        Result result = Result.error(400, message);
        response.getWriter().write(JsonUtils.toJson(result));
    }
}

/**
 * 幂等性注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    // 可以添加配置项
}

/**
 * 使用示例
 */
@RestController
@RequestMapping("api/payment")
public class PaymentController {
    
    /**
     * 创建支付订单（防止重复提交）
     */
    @PostMapping("/create")
    @Idempotent
    public Result createPayment(@RequestBody PaymentRequest request) {
        // ... 业务逻辑
    }
}
```

### 3.2 数据脱敏拦截器

```java
@Component
public class DataMaskingInterceptor implements HandlerInterceptor {
    
    @Override
    public void postHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        ModelAndView modelAndView
    ) throws Exception {
        
        if (!(handler instanceof HandlerMethod)) {
            return;
        }
        
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        
        // 检查方法上的脱敏注解
        DataMasking annotation = handlerMethod.getMethodAnnotation(DataMasking.class);
        if (annotation == null) {
            return;
        }
        
        // 获取响应数据并脱敏
        // 注意：这里需要配合 ResponseBodyAdvice 实现
    }
}

/**
 * 响应数据脱敏处理
 */
@ControllerAdvice
public class DataMaskingAdvice implements ResponseBodyAdvice<Object> {
    
    @Override
    public boolean supports(
        MethodParameter returnType,
        Class<? extends HttpMessageConverter<?>> converterType
    ) {
        return returnType.hasMethodAnnotation(DataMasking.class);
    }
    
    @Override
    public Object beforeBodyWrite(
        Object body,
        MethodParameter returnType,
        MediaType selectedContentType,
        Class<? extends HttpMessageConverter<?>> selectedConverterType,
        ServerHttpRequest request,
        ServerHttpResponse response
    ) {
        
        if (body instanceof Result) {
            Result result = (Result) body;
            Object data = result.getData();
            
            // 脱敏处理
            if (data != null) {
                result.setData(maskSensitiveData(data));
            }
        }
        
        return body;
    }
    
    /**
     * 脱敏敏感数据
     */
    private Object maskSensitiveData(Object data) {
        if (data == null) {
            return null;
        }
        
        // 使用反射处理对象字段
        Class<?> clazz = data.getClass();
        Field[] fields = clazz.getDeclaredFields();
        
        for (Field field : fields) {
            Sensitive annotation = field.getAnnotation(Sensitive.class);
            if (annotation != null) {
                field.setAccessible(true);
                try {
                    Object value = field.get(data);
                    if (value instanceof String) {
                        String maskedValue = maskString((String) value, annotation.type());
                        field.set(data, maskedValue);
                    }
                } catch (IllegalAccessException e) {
                    // 忽略
                }
            }
        }
        
        return data;
    }
    
    /**
     * 字符串脱敏
     */
    private String maskString(String value, SensitiveType type) {
        if (StringUtils.isEmpty(value)) {
            return value;
        }
        
        switch (type) {
            case MOBILE:
                // 手机号脱敏：138****5678
                if (value.length() == 11) {
                    return value.substring(0, 3) + "****" + value.substring(7);
                }
                break;
            case EMAIL:
                // 邮箱脱敏：ab***@example.com
                int atIndex = value.indexOf('@');
                if (atIndex > 0) {
                    String prefix = value.substring(0, Math.min(2, atIndex));
                    String suffix = value.substring(atIndex);
                    return prefix + "***" + suffix;
                }
                break;
            case ID_CARD:
                // 身份证脱敏：110***********1234
                if (value.length() >= 18) {
                    return value.substring(0, 3) + "***********" + value.substring(14);
                }
                break;
            case PASSWORD:
                // 密码脱敏：******
                return "******";
        }
        
        return value;
    }
}

/**
 * 敏感字段注解
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Sensitive {
    SensitiveType type();
}

public enum SensitiveType {
    MOBILE,     // 手机号
    EMAIL,      // 邮箱
    ID_CARD,    // 身份证
    PASSWORD    // 密码
}
```

### 3.3 签名验证拦截器

```java
@Component
public class SignatureInterceptor implements HandlerInterceptor {
    
    @Value("${signature.enabled:false}")
    private boolean enabled;
    
    @Value("${signature.secret-key}")
    private String secretKey;
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        if (!enabled) {
            return true;
        }
        
        if (!(handler instanceof HandlerMethod)) {
            return true;
        }
        
        HandlerMethod handlerMethod = (HandlerMethod) handler;
        
        // 检查方法上的签名注解
        RequireSignature annotation = handlerMethod.getMethodAnnotation(RequireSignature.class);
        if (annotation == null) {
            return true;
        }
        
        // 获取签名参数
        String timestamp = request.getHeader("X-Timestamp");
        String nonce = request.getHeader("X-Nonce");
        String signature = request.getHeader("X-Signature");
        
        // 验证参数
        if (StringUtils.isEmpty(timestamp) || 
            StringUtils.isEmpty(nonce) || 
            StringUtils.isEmpty(signature)) {
            sendErrorResponse(response, "缺少签名参数");
            return false;
        }
        
        // 验证时间戳（5 分钟内有效）
        long currentTime = System.currentTimeMillis();
        long requestTime = Long.parseLong(timestamp);
        if (Math.abs(currentTime - requestTime) > 5 * 60 * 1000) {
            sendErrorResponse(response, "请求已过期");
            return false;
        }
        
        // 获取请求体
        String body = getRequestBody(request);
        
        // 计算签名
        String expectedSignature = calculateSignature(timestamp, nonce, body);
        
        // 验证签名
        if (!expectedSignature.equals(signature)) {
            sendErrorResponse(response, "签名验证失败");
            return false;
        }
        
        return true;
    }
    
    /**
     * 计算签名
     */
    private String calculateSignature(String timestamp, String nonce, String body) {
        String data = timestamp + nonce + body + secretKey;
        return DigestUtils.md5Hex(data);
    }
    
    /**
     * 获取请求体
     */
    private String getRequestBody(HttpServletRequest request) throws IOException {
        // 使用 ContentCachingRequestWrapper 包装请求
        // 可以多次读取请求体
        return IOUtils.toString(request.getInputStream(), StandardCharsets.UTF_8);
    }
    
    private void sendErrorResponse(HttpServletResponse response, String message) 
        throws IOException {
        
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json;charset=UTF-8");
        
        Result result = Result.error(401, message);
        response.getWriter().write(JsonUtils.toJson(result));
    }
}
```

## 四、拦截器执行流程

### 4.1 执行顺序

```
请求到达
    ↓
preHandle (按 order 顺序执行)
    ├─ CorsInterceptor.preHandle()
    ├─ LogInterceptor.preHandle()
    ├─ AuthenticationInterceptor.preHandle()
    ├─ PermissionInterceptor.preHandle()
    ├─ TenantInterceptor.preHandle()
    └─ RateLimitInterceptor.preHandle()
    ↓
Controller 方法执行
    ↓
postHandle (按 order 逆序执行)
    ├─ RateLimitInterceptor.postHandle()
    ├─ TenantInterceptor.postHandle()
    ├─ PermissionInterceptor.postHandle()
    ├─ AuthenticationInterceptor.postHandle()
    ├─ LogInterceptor.postHandle()
    └─ CorsInterceptor.postHandle()
    ↓
视图渲染（如果有）
    ↓
afterCompletion (按 order 逆序执行)
    ├─ RateLimitInterceptor.afterCompletion()
    ├─ TenantInterceptor.afterCompletion()
    ├─ PermissionInterceptor.afterCompletion()
    ├─ AuthenticationInterceptor.afterCompletion()
    ├─ LogInterceptor.afterCompletion()
    └─ CorsInterceptor.afterCompletion()
    ↓
响应返回
```

### 4.2 异常处理流程

```
如果在 preHandle 中返回 false 或抛出异常：
    ├─ 停止执行后续拦截器
    ├─ 不执行 Controller 方法
    ├─ 不执行 postHandle
    └─ 执行已执行拦截器的 afterCompletion (逆序)

如果在 Controller 中抛出异常：
    ├─ 不执行 postHandle
    ├─ 执行所有拦截器的 afterCompletion (逆序)
    └─ 异常传递给全局异常处理器
```

## 五、拦截器最佳实践

### 5.1 拦截器设计原则

1. **单一职责**: 每个拦截器只负责一个特定功能
2. **顺序合理**: 认证 → 权限 → 业务逻辑的顺序
3. **性能优先**: 避免在拦截器中执行耗时操作
4. **异常安全**: 正确处理异常，避免影响其他拦截器
5. **资源清理**: 在 afterCompletion 中清理 ThreadLocal 等资源

### 5.2 性能优化建议

```java
@Component
public class OptimizedInterceptor implements HandlerInterceptor {
    
    // 1. 使用缓存避免重复查询
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 2. 使用白名单减少不必要的检查
    private static final Set<String> WHITE_LIST = new HashSet<>(
        Arrays.asList("/api/public/**", "/actuator/**")
    );
    
    // 3. 使用快速失败策略
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        // 快速检查：白名单直接放行
        if (isWhiteList(request.getRequestURI())) {
            return true;
        }
        
        // 快速检查：静态资源直接放行
        if (isStaticResource(request.getRequestURI())) {
            return true;
        }
        
        // 执行业务逻辑
        return doBusinessLogic(request, response, handler);
    }
    
    // 4. 异步处理非关键逻辑
    @Async
    public void asyncLog(String message) {
        // 异步记录日志
        log.info(message);
    }
}
```

### 5.3 常见问题与解决

#### 问题1：拦截器中无法获取请求体

```java
// 解决方案：使用 ContentCachingRequestWrapper
@Component
public class CachingRequestFilter extends OncePerRequestFilter {
    
    @Override
    protected void doFilterInternal(
        HttpServletRequest request,
        HttpServletResponse response,
        FilterChain filterChain
    ) throws ServletException, IOException {
        
        // 包装请求，允许多次读取请求体
        ContentCachingRequestWrapper wrappedRequest = 
            new ContentCachingRequestWrapper(request);
        
        filterChain.doFilter(wrappedRequest, response);
    }
}
```

#### 问题2：拦截器顺序不生效

```java
// 解决方案：明确指定 order
@Component
@Order(1)  // 使用 @Order 注解
public class FirstInterceptor implements HandlerInterceptor {
    // ...
}

// 或在配置中指定
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new FirstInterceptor()).order(1);
        registry.addInterceptor(new SecondInterceptor()).order(2);
    }
}
```

#### 问题3：ThreadLocal 内存泄漏

```java
// 解决方案：在 afterCompletion 中清理
@Override
public void afterCompletion(
    HttpServletRequest request,
    HttpServletResponse response,
    Object handler,
    Exception ex
) throws Exception {
    // 必须清理 ThreadLocal
    UserContext.clear();
    TenantContext.clear();
}
```

## 六、总结

### 6.1 拦截器体系核心

DataSophon API 拦截器体系包括：

1. ✅ **CORS 拦截器**: 跨域请求处理
2. ✅ **日志拦截器**: 请求日志记录和监控
3. ✅ **认证拦截器**: 用户身份验证
4. ✅ **权限拦截器**: 资源访问控制
5. ✅ **租户拦截器**: 多租户数据隔离
6. ✅ **限流拦截器**: 请求频率控制
7. ✅ **幂等性拦截器**: 防止重复提交
8. ✅ **签名拦截器**: API 签名验证

### 6.2 技术亮点

1. **分层设计**: 职责清晰，便于维护
2. **可配置化**: 支持开关和参数配置
3. **高性能**: 缓存、异步、快速失败
4. **安全可靠**: 多重安全防护机制
5. **易扩展**: 基于接口，便于扩展新功能

---

**文档版本**: v1.0  
**最后更新**: 2025-11-16  
**维护团队**: DataSophon 源码分析团队
