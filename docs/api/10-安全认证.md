# DataSophon API 安全认证详解

## 一、安全认证概述

### 1.1 安全体系架构

DataSophon API 采用多层安全防护体系，确保系统安全可靠：

```
┌─────────────────────────────────────────┐
│         前端 Web 应用                    │
└─────────────┬───────────────────────────┘
              │ HTTPS
              ↓
┌─────────────────────────────────────────┐
│         Nginx/网关层                     │
│  - SSL/TLS 加密                          │
│  - 请求限流                              │
│  - 防火墙规则                            │
└─────────────┬───────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────┐
│      DataSophon API 安全层               │
│  1. 认证 (Authentication)                │
│     - 用户名密码登录                      │
│     - Token 验证                         │
│     - Session 管理                       │
│  2. 授权 (Authorization)                 │
│     - RBAC 权限模型                      │
│     - 集群级权限控制                      │
│     - 操作权限验证                       │
│  3. 审计 (Audit)                        │
│     - 操作日志记录                       │
│     - 敏感操作审计                       │
└─────────────┬───────────────────────────┘
              │
              ↓
┌─────────────────────────────────────────┐
│       Service/DAO 层                     │
└─────────────────────────────────────────┘
```

### 1.2 核心安全特性

1. **身份认证**: 用户名密码认证、Token 令牌认证
2. **权限授权**: RBAC 角色权限模型、细粒度权限控制
3. **会话管理**: Redis 分布式会话、会话超时控制
4. **密码安全**: BCrypt 加密、密码强度验证
5. **防护机制**: XSS 防护、CSRF 防护、SQL 注入防护
6. **审计日志**: 操作日志、登录日志、敏感操作审计

## 二、认证机制详解

### 2.1 用户登录认证

#### 2.1.1 LoginController

```java
@RestController
@RequestMapping("api/login")
public class LoginController {
    
    @Autowired
    private UserInfoService userInfoService;
    
    @Autowired
    private SessionService sessionService;
    
    @Autowired
    private AuditLogService auditLogService;
    
    /**
     * 用户登录
     */
    @PostMapping("/signin")
    public Result signin(@RequestBody LoginRequest request) {
        // 1. 参数验证
        validateLoginRequest(request);
        
        // 2. 用户认证
        UserInfoEntity user = userInfoService.authenticate(
            request.getUsername(),
            request.getPassword()
        );
        
        if (user == null) {
            // 记录登录失败
            auditLogService.recordLoginFailure(request.getUsername(), getClientIp());
            return Result.error("用户名或密码错误");
        }
        
        // 3. 检查用户状态
        if (UserState.DISABLED.equals(user.getState())) {
            return Result.error("用户已被禁用");
        }
        
        // 4. 生成 Token
        String token = TokenUtils.generateToken(user.getId());
        
        // 5. 创建会话
        SessionInfo session = sessionService.createSession(user, token);
        
        // 6. 记录登录成功
        auditLogService.recordLoginSuccess(user.getId(), getClientIp());
        
        // 7. 返回登录结果
        LoginResponse response = new LoginResponse();
        response.setToken(token);
        response.setUserInfo(buildUserInfo(user));
        response.setExpireTime(session.getExpireTime());
        
        return Result.success(response);
    }
    
    /**
     * 用户登出
     */
    @PostMapping("/signout")
    public Result signout() {
        // 获取当前用户会话
        String token = getCurrentToken();
        if (StringUtils.isEmpty(token)) {
            return Result.error("未登录");
        }
        
        // 销毁会话
        sessionService.destroySession(token);
        
        // 记录登出日志
        auditLogService.recordLogout(getCurrentUserId());
        
        return Result.success();
    }
    
    /**
     * 刷新 Token
     */
    @PostMapping("/refreshToken")
    public Result refreshToken() {
        String oldToken = getCurrentToken();
        
        // 验证 Token 有效性
        if (!sessionService.isValidToken(oldToken)) {
            return Result.error("Token 已失效，请重新登录");
        }
        
        // 生成新 Token
        Integer userId = sessionService.getUserId(oldToken);
        String newToken = TokenUtils.generateToken(userId);
        
        // 更新会话
        sessionService.refreshSession(oldToken, newToken);
        
        return Result.success(newToken);
    }
    
    /**
     * 获取验证码
     */
    @GetMapping("/captcha")
    public Result getCaptcha() {
        // 生成验证码
        CaptchaInfo captcha = CaptchaUtils.generateCaptcha();
        
        // 存储到 Redis（5 分钟有效期）
        String key = "captcha:" + captcha.getId();
        redisTemplate.opsForValue().set(key, captcha.getCode(), 5, TimeUnit.MINUTES);
        
        // 返回验证码图片（Base64）
        Map<String, Object> result = new HashMap<>();
        result.put("captchaId", captcha.getId());
        result.put("captchaImage", captcha.getImageBase64());
        
        return Result.success(result);
    }
}
```

**登录请求对象**:
```java
@Data
public class LoginRequest {
    
    @NotBlank(message = "用户名不能为空")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    private String password;
    
    /**
     * 验证码 ID
     */
    private String captchaId;
    
    /**
     * 验证码
     */
    private String captchaCode;
    
    /**
     * 记住我（7天免登录）
     */
    private Boolean rememberMe;
}
```

**登录响应对象**:
```java
@Data
public class LoginResponse {
    
    /**
     * 访问令牌
     */
    private String token;
    
    /**
     * 用户信息
     */
    private UserInfo userInfo;
    
    /**
     * Token 过期时间
     */
    private Long expireTime;
    
    /**
     * 用户权限列表
     */
    private List<String> permissions;
    
    /**
     * 用户角色列表
     */
    private List<String> roles;
}
```

#### 2.1.2 用户认证服务

```java
@Service
public class UserInfoService {
    
    @Autowired
    private UserInfoMapper userMapper;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    /**
     * 用户认证
     */
    public UserInfoEntity authenticate(String username, String password) {
        // 查询用户
        UserInfoEntity user = userMapper.selectByUsername(username);
        if (user == null) {
            return null;
        }
        
        // 验证密码
        if (!passwordEncoder.matches(password, user.getPassword())) {
            return null;
        }
        
        return user;
    }
    
    /**
     * 修改密码
     */
    @Transactional
    public void changePassword(Integer userId, String oldPassword, String newPassword) {
        // 查询用户
        UserInfoEntity user = userMapper.selectById(userId);
        if (user == null) {
            throw new ApiException("用户不存在");
        }
        
        // 验证旧密码
        if (!passwordEncoder.matches(oldPassword, user.getPassword())) {
            throw new ApiException("原密码不正确");
        }
        
        // 验证新密码强度
        validatePasswordStrength(newPassword);
        
        // 加密新密码
        String encodedPassword = passwordEncoder.encode(newPassword);
        
        // 更新密码
        user.setPassword(encodedPassword);
        user.setUpdateTime(LocalDateTime.now());
        userMapper.updateById(user);
        
        // 记录密码修改日志
        auditLogService.recordPasswordChange(userId);
    }
    
    /**
     * 密码强度验证
     */
    private void validatePasswordStrength(String password) {
        // 长度检查
        if (password.length() < 8) {
            throw new ApiException("密码长度不能少于 8 位");
        }
        
        // 复杂度检查：必须包含数字、字母、特殊字符
        boolean hasDigit = password.matches(".*\\d.*");
        boolean hasLetter = password.matches(".*[a-zA-Z].*");
        boolean hasSpecial = password.matches(".*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>/?].*");
        
        int complexity = 0;
        if (hasDigit) complexity++;
        if (hasLetter) complexity++;
        if (hasSpecial) complexity++;
        
        if (complexity < 2) {
            throw new ApiException("密码必须包含数字、字母、特殊字符中的至少两种");
        }
    }
}
```

### 2.2 Token 令牌机制

#### 2.2.1 Token 生成与验证

```java
public class TokenUtils {
    
    private static final String SECRET_KEY = "datasophon-secret-key-2024";
    private static final long EXPIRE_TIME = 24 * 60 * 60 * 1000; // 24 小时
    
    /**
     * 生成 Token
     */
    public static String generateToken(Integer userId) {
        Date now = new Date();
        Date expireDate = new Date(now.getTime() + EXPIRE_TIME);
        
        return Jwts.builder()
            .setSubject(String.valueOf(userId))
            .setIssuedAt(now)
            .setExpiration(expireDate)
            .signWith(SignatureAlgorithm.HS512, SECRET_KEY)
            .compact();
    }
    
    /**
     * 从 Token 中解析用户 ID
     */
    public static Integer getUserIdFromToken(String token) {
        try {
            Claims claims = Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody();
            
            return Integer.parseInt(claims.getSubject());
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * 验证 Token 是否有效
     */
    public static boolean validateToken(String token) {
        try {
            Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token);
            return true;
        } catch (ExpiredJwtException e) {
            // Token 已过期
            return false;
        } catch (Exception e) {
            // Token 无效
            return false;
        }
    }
    
    /**
     * 检查 Token 是否即将过期（1小时内）
     */
    public static boolean isTokenExpiringSoon(String token) {
        try {
            Claims claims = Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody();
            
            Date expiration = claims.getExpiration();
            long remainingTime = expiration.getTime() - System.currentTimeMillis();
            
            return remainingTime < 60 * 60 * 1000; // 剩余时间少于 1 小时
        } catch (Exception e) {
            return true;
        }
    }
}
```

#### 2.2.2 会话管理服务

```java
@Service
public class SessionService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String SESSION_PREFIX = "session:";
    private static final long SESSION_TIMEOUT = 24 * 60 * 60; // 24 小时
    
    /**
     * 创建会话
     */
    public SessionInfo createSession(UserInfoEntity user, String token) {
        SessionInfo session = new SessionInfo();
        session.setUserId(user.getId());
        session.setUsername(user.getUsername());
        session.setToken(token);
        session.setLoginTime(System.currentTimeMillis());
        session.setExpireTime(System.currentTimeMillis() + SESSION_TIMEOUT * 1000);
        session.setLastAccessTime(System.currentTimeMillis());
        
        // 存储到 Redis
        String key = SESSION_PREFIX + token;
        redisTemplate.opsForValue().set(key, session, SESSION_TIMEOUT, TimeUnit.SECONDS);
        
        return session;
    }
    
    /**
     * 获取会话信息
     */
    public SessionInfo getSession(String token) {
        String key = SESSION_PREFIX + token;
        return (SessionInfo) redisTemplate.opsForValue().get(key);
    }
    
    /**
     * 更新会话最后访问时间
     */
    public void updateLastAccessTime(String token) {
        SessionInfo session = getSession(token);
        if (session != null) {
            session.setLastAccessTime(System.currentTimeMillis());
            
            String key = SESSION_PREFIX + token;
            redisTemplate.opsForValue().set(key, session, SESSION_TIMEOUT, TimeUnit.SECONDS);
        }
    }
    
    /**
     * 销毁会话
     */
    public void destroySession(String token) {
        String key = SESSION_PREFIX + token;
        redisTemplate.delete(key);
    }
    
    /**
     * 获取用户的所有会话
     */
    public List<SessionInfo> getUserSessions(Integer userId) {
        String pattern = SESSION_PREFIX + "*";
        Set<String> keys = redisTemplate.keys(pattern);
        
        List<SessionInfo> sessions = new ArrayList<>();
        for (String key : keys) {
            SessionInfo session = (SessionInfo) redisTemplate.opsForValue().get(key);
            if (session != null && session.getUserId().equals(userId)) {
                sessions.add(session);
            }
        }
        
        return sessions;
    }
    
    /**
     * 踢出用户（强制下线）
     */
    public void kickOutUser(Integer userId) {
        List<SessionInfo> sessions = getUserSessions(userId);
        for (SessionInfo session : sessions) {
            destroySession(session.getToken());
        }
    }
}
```

**会话信息对象**:
```java
@Data
public class SessionInfo implements Serializable {
    
    /**
     * 用户 ID
     */
    private Integer userId;
    
    /**
     * 用户名
     */
    private String username;
    
    /**
     * Token
     */
    private String token;
    
    /**
     * 登录时间
     */
    private Long loginTime;
    
    /**
     * 过期时间
     */
    private Long expireTime;
    
    /**
     * 最后访问时间
     */
    private Long lastAccessTime;
    
    /**
     * 登录 IP
     */
    private String loginIp;
    
    /**
     * 用户代理
     */
    private String userAgent;
}
```

### 2.3 认证拦截器

```java
@Component
public class AuthenticationInterceptor implements HandlerInterceptor {
    
    @Autowired
    private SessionService sessionService;
    
    /**
     * 白名单（不需要认证的接口）
     */
    private static final Set<String> WHITE_LIST = new HashSet<>(Arrays.asList(
        "/api/login/signin",
        "/api/login/signout",
        "/api/login/captcha",
        "/actuator/health"
    ));
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        String uri = request.getRequestURI();
        
        // 白名单放行
        if (isWhiteList(uri)) {
            return true;
        }
        
        // 获取 Token
        String token = getTokenFromRequest(request);
        if (StringUtils.isEmpty(token)) {
            sendUnauthorizedResponse(response, "未登录或登录已过期");
            return false;
        }
        
        // 验证 Token
        if (!TokenUtils.validateToken(token)) {
            sendUnauthorizedResponse(response, "Token 无效或已过期");
            return false;
        }
        
        // 验证会话
        SessionInfo session = sessionService.getSession(token);
        if (session == null) {
            sendUnauthorizedResponse(response, "会话已失效");
            return false;
        }
        
        // 更新最后访问时间
        sessionService.updateLastAccessTime(token);
        
        // 将用户信息放入请求上下文
        UserContext.setCurrentUser(session.getUserId(), session.getUsername());
        
        return true;
    }
    
    @Override
    public void afterCompletion(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        Exception ex
    ) throws Exception {
        // 清理线程变量
        UserContext.clear();
    }
    
    /**
     * 从请求中获取 Token
     */
    private String getTokenFromRequest(HttpServletRequest request) {
        // 1. 从 Header 中获取
        String token = request.getHeader("Authorization");
        if (StringUtils.isNotEmpty(token) && token.startsWith("Bearer ")) {
            return token.substring(7);
        }
        
        // 2. 从参数中获取
        token = request.getParameter("token");
        if (StringUtils.isNotEmpty(token)) {
            return token;
        }
        
        return null;
    }
    
    /**
     * 发送未授权响应
     */
    private void sendUnauthorizedResponse(HttpServletResponse response, String message) 
        throws IOException {
        
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json;charset=UTF-8");
        
        Result result = Result.error(401, message);
        response.getWriter().write(JsonUtils.toJson(result));
    }
    
    /**
     * 判断是否在白名单中
     */
    private boolean isWhiteList(String uri) {
        return WHITE_LIST.stream().anyMatch(uri::startsWith);
    }
}
```

### 2.4 用户上下文

```java
/**
 * 用户上下文（ThreadLocal）
 */
public class UserContext {
    
    private static final ThreadLocal<UserInfo> USER_HOLDER = new ThreadLocal<>();
    
    /**
     * 设置当前用户
     */
    public static void setCurrentUser(Integer userId, String username) {
        UserInfo userInfo = new UserInfo();
        userInfo.setUserId(userId);
        userInfo.setUsername(username);
        USER_HOLDER.set(userInfo);
    }
    
    /**
     * 获取当前用户
     */
    public static UserInfo getCurrentUser() {
        return USER_HOLDER.get();
    }
    
    /**
     * 获取当前用户 ID
     */
    public static Integer getCurrentUserId() {
        UserInfo user = USER_HOLDER.get();
        return user != null ? user.getUserId() : null;
    }
    
    /**
     * 获取当前用户名
     */
    public static String getCurrentUsername() {
        UserInfo user = USER_HOLDER.get();
        return user != null ? user.getUsername() : null;
    }
    
    /**
     * 清理上下文
     */
    public static void clear() {
        USER_HOLDER.remove();
    }
}
```

## 三、授权机制详解

### 3.1 RBAC 权限模型

DataSophon 采用 **基于角色的访问控制（RBAC）** 模型：

```
用户 (User)
  ↓ N:N
角色 (Role)
  ↓ N:N
权限 (Permission)
  ↓
资源 (Resource)
```

**实体关系**:

| 实体 | 说明 | 示例 |
|-----|------|------|
| User | 用户 | admin, operator, viewer |
| Role | 角色 | 管理员、运维人员、查看者 |
| Permission | 权限 | cluster:create, service:start |
| Resource | 资源 | 集群、服务、主机 |

### 3.2 权限注解

#### 3.2.1 自定义权限注解

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RequiresPermissions {
    
    /**
     * 需要的权限
     */
    String[] value();
    
    /**
     * 权限逻辑（AND 或 OR）
     */
    Logical logical() default Logical.AND;
}

public enum Logical {
    AND,  // 需要所有权限
    OR    // 需要任意一个权限
}
```

#### 3.2.2 使用示例

```java
@RestController
@RequestMapping("api/cluster")
public class ClusterInfoController {
    
    /**
     * 创建集群（需要 cluster:create 权限）
     */
    @PostMapping("/save")
    @RequiresPermissions("cluster:create")
    public Result saveCluster(@RequestBody ClusterInfoEntity cluster) {
        // ... 业务逻辑
    }
    
    /**
     * 删除集群（需要 cluster:delete 权限）
     */
    @PostMapping("/delete")
    @RequiresPermissions("cluster:delete")
    public Result deleteCluster(@RequestBody Integer[] ids) {
        // ... 业务逻辑
    }
    
    /**
     * 启动服务（需要 service:start 或 service:manage 权限）
     */
    @PostMapping("/service/start")
    @RequiresPermissions(value = {"service:start", "service:manage"}, logical = Logical.OR)
    public Result startService(Integer serviceId) {
        // ... 业务逻辑
    }
}
```

### 3.3 权限验证拦截器

```java
@Aspect
@Component
public class PermissionAspect {
    
    @Autowired
    private PermissionService permissionService;
    
    @Around("@annotation(requiresPermissions)")
    public Object checkPermission(
        ProceedingJoinPoint joinPoint,
        RequiresPermissions requiresPermissions
    ) throws Throwable {
        
        // 获取当前用户
        Integer userId = UserContext.getCurrentUserId();
        if (userId == null) {
            throw new UnauthorizedException("用户未登录");
        }
        
        // 获取需要的权限
        String[] permissions = requiresPermissions.value();
        Logical logical = requiresPermissions.logical();
        
        // 验证权限
        boolean hasPermission;
        if (logical == Logical.AND) {
            // 需要所有权限
            hasPermission = permissionService.hasAllPermissions(userId, permissions);
        } else {
            // 需要任意一个权限
            hasPermission = permissionService.hasAnyPermission(userId, permissions);
        }
        
        if (!hasPermission) {
            throw new ForbiddenException("权限不足");
        }
        
        // 执行目标方法
        return joinPoint.proceed();
    }
}
```

### 3.4 权限服务

```java
@Service
public class PermissionService {
    
    @Autowired
    private UserRoleMapper userRoleMapper;
    
    @Autowired
    private RolePermissionMapper rolePermissionMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String PERMISSION_CACHE_PREFIX = "user:permissions:";
    private static final long CACHE_EXPIRE_TIME = 30 * 60; // 30 分钟
    
    /**
     * 获取用户的所有权限
     */
    public Set<String> getUserPermissions(Integer userId) {
        // 先从缓存获取
        String cacheKey = PERMISSION_CACHE_PREFIX + userId;
        Set<String> permissions = (Set<String>) redisTemplate.opsForValue().get(cacheKey);
        
        if (permissions != null) {
            return permissions;
        }
        
        // 从数据库查询
        permissions = new HashSet<>();
        
        // 1. 查询用户的角色
        List<Integer> roleIds = userRoleMapper.selectRoleIdsByUserId(userId);
        
        // 2. 查询角色的权限
        for (Integer roleId : roleIds) {
            List<String> rolePermissions = rolePermissionMapper.selectPermissionsByRoleId(roleId);
            permissions.addAll(rolePermissions);
        }
        
        // 3. 缓存权限
        redisTemplate.opsForValue().set(cacheKey, permissions, CACHE_EXPIRE_TIME, TimeUnit.SECONDS);
        
        return permissions;
    }
    
    /**
     * 检查用户是否拥有所有权限
     */
    public boolean hasAllPermissions(Integer userId, String[] permissions) {
        Set<String> userPermissions = getUserPermissions(userId);
        return userPermissions.containsAll(Arrays.asList(permissions));
    }
    
    /**
     * 检查用户是否拥有任意一个权限
     */
    public boolean hasAnyPermission(Integer userId, String[] permissions) {
        Set<String> userPermissions = getUserPermissions(userId);
        for (String permission : permissions) {
            if (userPermissions.contains(permission)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * 检查用户是否有集群权限
     */
    public boolean hasClusterPermission(Integer userId, Integer clusterId) {
        // 管理员拥有所有集群权限
        if (isAdmin(userId)) {
            return true;
        }
        
        // 查询用户的集群权限
        List<Integer> clusterIds = userRoleMapper.selectClusterIdsByUserId(userId);
        return clusterIds.contains(clusterId);
    }
    
    /**
     * 判断是否为管理员
     */
    public boolean isAdmin(Integer userId) {
        List<Integer> roleIds = userRoleMapper.selectRoleIdsByUserId(userId);
        // 角色 ID 为 1 的是管理员
        return roleIds.contains(1);
    }
    
    /**
     * 清除用户权限缓存
     */
    public void clearPermissionCache(Integer userId) {
        String cacheKey = PERMISSION_CACHE_PREFIX + userId;
        redisTemplate.delete(cacheKey);
    }
}
```

## 四、安全防护机制

### 4.1 XSS 防护

```java
@Component
public class XssFilter implements Filter {
    
    @Override
    public void doFilter(
        ServletRequest request,
        ServletResponse response,
        FilterChain chain
    ) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        // 包装请求，过滤 XSS
        XssHttpServletRequestWrapper wrappedRequest = 
            new XssHttpServletRequestWrapper(httpRequest);
        
        chain.doFilter(wrappedRequest, response);
    }
}

/**
 * XSS 请求包装器
 */
public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {
    
    public XssHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);
    }
    
    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return cleanXss(value);
    }
    
    @Override
    public String[] getParameterValues(String name) {
        String[] values = super.getParameterValues(name);
        if (values == null) {
            return null;
        }
        
        String[] cleanValues = new String[values.length];
        for (int i = 0; i < values.length; i++) {
            cleanValues[i] = cleanXss(values[i]);
        }
        return cleanValues;
    }
    
    /**
     * 清理 XSS
     */
    private String cleanXss(String value) {
        if (value == null) {
            return null;
        }
        
        // 移除脚本标签
        value = value.replaceAll("<script.*?>.*?</script>", "");
        value = value.replaceAll("<iframe.*?>.*?</iframe>", "");
        value = value.replaceAll("javascript:", "");
        value = value.replaceAll("on\\w+\\s*=", "");
        
        // HTML 实体编码
        value = StringEscapeUtils.escapeHtml4(value);
        
        return value;
    }
}
```

### 4.2 CSRF 防护

```java
@Component
public class CsrfTokenInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String CSRF_TOKEN_HEADER = "X-CSRF-Token";
    private static final String CSRF_TOKEN_PREFIX = "csrf:token:";
    
    @Override
    public boolean preHandle(
        HttpServletRequest request,
        HttpServletResponse response,
        Object handler
    ) throws Exception {
        
        String method = request.getMethod();
        
        // GET、HEAD、OPTIONS 请求不需要 CSRF Token
        if ("GET".equals(method) || "HEAD".equals(method) || "OPTIONS".equals(method)) {
            return true;
        }
        
        // 获取并验证 CSRF Token
        String token = request.getHeader(CSRF_TOKEN_HEADER);
        if (StringUtils.isEmpty(token)) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write("CSRF Token 缺失");
            return false;
        }
        
        // 从 Redis 验证 Token
        String cacheKey = CSRF_TOKEN_PREFIX + token;
        String cachedToken = redisTemplate.opsForValue().get(cacheKey);
        
        if (cachedToken == null) {
            response.setStatus(HttpServletResponse.SC_FORBIDDEN);
            response.getWriter().write("CSRF Token 无效或已过期");
            return false;
        }
        
        return true;
    }
}

/**
 * CSRF Token 生成
 */
@RestController
@RequestMapping("api/csrf")
public class CsrfController {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    @GetMapping("/token")
    public Result getCsrfToken() {
        // 生成随机 Token
        String token = UUID.randomUUID().toString().replace("-", "");
        
        // 存储到 Redis（1 小时有效期）
        String cacheKey = "csrf:token:" + token;
        redisTemplate.opsForValue().set(cacheKey, token, 1, TimeUnit.HOURS);
        
        return Result.success(token);
    }
}
```

### 4.3 SQL 注入防护

```java
/**
 * MyBatis 使用预编译语句防止 SQL 注入
 */
@Mapper
public interface ClusterInfoMapper extends BaseMapper<ClusterInfoEntity> {
    
    /**
     * 安全的查询方式（使用 #{}）
     */
    @Select("SELECT * FROM t_cluster_info WHERE cluster_name = #{clusterName}")
    ClusterInfoEntity selectByName(@Param("clusterName") String clusterName);
    
    /**
     * 不安全的查询方式（使用 ${}），仅在特殊场景使用
     * 注意：使用 ${} 时必须手动验证和过滤参数
     */
    // @Select("SELECT * FROM t_cluster_info WHERE ${columnName} = #{value}")
    // List<ClusterInfoEntity> selectByColumn(@Param("columnName") String columnName, @Param("value") String value);
}

/**
 * SQL 注入防护工具类
 */
public class SqlInjectionUtils {
    
    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(
        "('.+(--)|\\s+(OR|AND)\\s+.+=.+|;\\s*(DROP|DELETE|UPDATE|INSERT))",
        Pattern.CASE_INSENSITIVE
    );
    
    /**
     * 检查是否包含 SQL 注入
     */
    public static boolean containsSqlInjection(String input) {
        if (StringUtils.isEmpty(input)) {
            return false;
        }
        return SQL_INJECTION_PATTERN.matcher(input).find();
    }
    
    /**
     * 验证列名（仅允许字母、数字、下划线）
     */
    public static boolean isValidColumnName(String columnName) {
        return columnName.matches("^[a-zA-Z0-9_]+$");
    }
}
```

### 4.4 请求限流

```java
@Aspect
@Component
public class RateLimitAspect {
    
    @Autowired
    private RedisTemplate<String, Long> redisTemplate;
    
    @Around("@annotation(rateLimit)")
    public Object rateLimit(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        // 获取限流键（用户 ID + 接口路径）
        Integer userId = UserContext.getCurrentUserId();
        String methodName = joinPoint.getSignature().getName();
        String key = String.format("rate:limit:%d:%s", userId, methodName);
        
        // 获取当前计数
        Long count = redisTemplate.opsForValue().get(key);
        if (count == null) {
            // 首次请求，设置计数为 1
            redisTemplate.opsForValue().set(key, 1L, rateLimit.period(), TimeUnit.SECONDS);
        } else if (count >= rateLimit.count()) {
            // 超过限流阈值
            throw new RateLimitException("请求过于频繁，请稍后再试");
        } else {
            // 增加计数
            redisTemplate.opsForValue().increment(key);
        }
        
        return joinPoint.proceed();
    }
}

/**
 * 限流注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    
    /**
     * 时间窗口内允许的请求数
     */
    int count() default 100;
    
    /**
     * 时间窗口（秒）
     */
    int period() default 60;
}

/**
 * 使用示例
 */
@RestController
@RequestMapping("api/cluster")
public class ClusterInfoController {
    
    /**
     * 限制每个用户每分钟最多创建 10 个集群
     */
    @PostMapping("/save")
    @RateLimit(count = 10, period = 60)
    public Result saveCluster(@RequestBody ClusterInfoEntity cluster) {
        // ... 业务逻辑
    }
}
```

## 五、审计日志

### 5.1 审计日志实体

```java
@Data
@TableName("t_audit_log")
public class AuditLog {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    /**
     * 用户 ID
     */
    private Integer userId;
    
    /**
     * 用户名
     */
    private String username;
    
    /**
     * 操作类型
     */
    private String operationType; // LOGIN, LOGOUT, CREATE, UPDATE, DELETE
    
    /**
     * 操作模块
     */
    private String module; // CLUSTER, SERVICE, HOST, USER
    
    /**
     * 操作描述
     */
    private String operationDesc;
    
    /**
     * 请求 URI
     */
    private String requestUri;
    
    /**
     * 请求方法
     */
    private String requestMethod; // GET, POST, PUT, DELETE
    
    /**
     * 请求参数
     */
    private String requestParams;
    
    /**
     * 响应结果
     */
    private String responseResult;
    
    /**
     * 客户端 IP
     */
    private String clientIp;
    
    /**
     * User-Agent
     */
    private String userAgent;
    
    /**
     * 操作状态
     */
    private String status; // SUCCESS, FAILURE
    
    /**
     * 错误信息
     */
    private String errorMsg;
    
    /**
     * 执行时间（毫秒）
     */
    private Long executionTime;
    
    /**
     * 创建时间
     */
    private LocalDateTime createTime;
}
```

### 5.2 审计日志切面

```java
@Aspect
@Component
public class AuditLogAspect {
    
    @Autowired
    private AuditLogService auditLogService;
    
    @Around("@annotation(auditLog)")
    public Object logAudit(ProceedingJoinPoint joinPoint, AuditLog auditLog) throws Throwable {
        long startTime = System.currentTimeMillis();
        
        // 构建审计日志对象
        AuditLog log = buildAuditLog(joinPoint, auditLog);
        
        try {
            // 执行目标方法
            Object result = joinPoint.proceed();
            
            // 记录成功日志
            log.setStatus("SUCCESS");
            log.setResponseResult(JsonUtils.toJson(result));
            log.setExecutionTime(System.currentTimeMillis() - startTime);
            
            auditLogService.saveLog(log);
            
            return result;
            
        } catch (Exception e) {
            // 记录失败日志
            log.setStatus("FAILURE");
            log.setErrorMsg(e.getMessage());
            log.setExecutionTime(System.currentTimeMillis() - startTime);
            
            auditLogService.saveLog(log);
            
            throw e;
        }
    }
    
    private AuditLog buildAuditLog(ProceedingJoinPoint joinPoint, AuditLog annotation) {
        AuditLog log = new AuditLog();
        
        // 用户信息
        log.setUserId(UserContext.getCurrentUserId());
        log.setUsername(UserContext.getCurrentUsername());
        
        // 操作信息
        log.setOperationType(annotation.operationType());
        log.setModule(annotation.module());
        log.setOperationDesc(annotation.description());
        
        // 请求信息
        HttpServletRequest request = getCurrentRequest();
        if (request != null) {
            log.setRequestUri(request.getRequestURI());
            log.setRequestMethod(request.getMethod());
            log.setClientIp(getClientIp(request));
            log.setUserAgent(request.getHeader("User-Agent"));
        }
        
        // 请求参数
        Object[] args = joinPoint.getArgs();
        log.setRequestParams(JsonUtils.toJson(args));
        
        log.setCreateTime(LocalDateTime.now());
        
        return log;
    }
}
```

## 六、最佳实践

### 6.1 安全配置清单

- ✅ 使用 HTTPS 加密传输
- ✅ 密码使用 BCrypt 加密存储
- ✅ Token 设置合理的过期时间
- ✅ 会话超时自动登出
- ✅ 实施 RBAC 权限控制
- ✅ 敏感操作需要二次验证
- ✅ 记录完整的审计日志
- ✅ 防护 XSS、CSRF、SQL 注入
- ✅ 接口请求限流
- ✅ 定期更新安全补丁

### 6.2 密码策略建议

1. **密码复杂度**: 至少 8 位，包含数字、字母、特殊字符
2. **密码有效期**: 建议 90 天更换一次
3. **密码历史**: 不能重复最近 5 次使用过的密码
4. **登录失败**: 连续 5 次失败锁定账户 30 分钟
5. **初始密码**: 强制用户首次登录修改密码

### 6.3 Token 管理建议

1. **Token 过期**: 24 小时自动过期
2. **刷新机制**: 提供 Token 刷新接口
3. **单点登录**: 支持多设备同时登录或强制单设备
4. **Token 撤销**: 提供强制下线功能
5. **Token 加密**: 使用 JWT 并签名防篡改

## 七、总结

### 7.1 安全体系核心

DataSophon API 安全认证体系包括：

1. ✅ **身份认证**: 用户名密码 + Token 双重认证
2. ✅ **权限授权**: RBAC 模型 + 细粒度权限控制
3. ✅ **会话管理**: Redis 分布式会话 + 超时控制
4. ✅ **安全防护**: XSS/CSRF/SQL注入防护 + 请求限流
5. ✅ **审计日志**: 完整的操作日志记录

### 7.2 技术亮点

1. **JWT Token**: 无状态认证，支持分布式部署
2. **Redis 会话**: 分布式会话管理，支持集群
3. **AOP 切面**: 权限验证和审计日志的优雅实现
4. **多级缓存**: 权限缓存提升性能
5. **ThreadLocal**: 线程级用户上下文管理

---

**文档版本**: v1.0  
**最后更新**: 2025-11-16  
**维护团队**: DataSophon 源码分析团队
