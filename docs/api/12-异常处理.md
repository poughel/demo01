# DataSophon API 异常处理详解

## 一、异常处理概述

### 1.1 异常处理架构

DataSophon API 采用统一的异常处理架构，确保错误信息的一致性和可维护性：

```
异常发生
    ↓
┌──────────────────────────────────┐
│     业务异常 (Business)           │
│  - ApiException                  │
│  - ServiceException              │
│  - BusinessException             │
└──────────────┬───────────────────┘
               │
               ↓
┌──────────────────────────────────┐
│     系统异常 (System)             │
│  - DataAccessException           │
│  - NullPointerException          │
│  - RuntimeException              │
└──────────────┬───────────────────┘
               │
               ↓
┌──────────────────────────────────┐
│     HTTP 异常 (HTTP)              │
│  - 401 Unauthorized              │
│  - 403 Forbidden                 │
│  - 404 Not Found                 │
│  - 500 Internal Server Error     │
└──────────────┬───────────────────┘
               │
               ↓
┌──────────────────────────────────┐
│   GlobalExceptionHandler         │
│   统一异常处理器                  │
└──────────────┬───────────────────┘
               │
               ↓
┌──────────────────────────────────┐
│      统一响应格式                 │
│      Result 对象                  │
└──────────────────────────────────┘
```

### 1.2 异常分类

| 异常类型 | HTTP 状态码 | 说明 | 处理方式 |
|---------|------------|------|---------|
| ApiException | 200 | 业务异常 | 返回错误信息 |
| UnauthorizedException | 401 | 未认证 | 重定向到登录页 |
| ForbiddenException | 403 | 无权限 | 提示权限不足 |
| NotFoundException | 404 | 资源不存在 | 提示资源未找到 |
| ValidationException | 400 | 参数验证失败 | 返回验证错误详情 |
| RateLimitException | 429 | 请求过于频繁 | 提示稍后重试 |
| SystemException | 500 | 系统错误 | 记录日志，返回通用错误 |

## 二、自定义异常类

### 2.1 基础异常类

```java
/**
 * API 基础异常
 */
public class ApiException extends RuntimeException {
    
    /**
     * 错误码
     */
    private Integer code;
    
    /**
     * 错误消息
     */
    private String message;
    
    /**
     * 错误详情
     */
    private Object details;
    
    public ApiException(String message) {
        super(message);
        this.code = 500;
        this.message = message;
    }
    
    public ApiException(Integer code, String message) {
        super(message);
        this.code = code;
        this.message = message;
    }
    
    public ApiException(Integer code, String message, Object details) {
        super(message);
        this.code = code;
        this.message = message;
        this.details = details;
    }
    
    public ApiException(String message, Throwable cause) {
        super(message, cause);
        this.code = 500;
        this.message = message;
    }
    
    // Getters and Setters
    public Integer getCode() {
        return code;
    }
    
    public void setCode(Integer code) {
        this.code = code;
    }
    
    @Override
    public String getMessage() {
        return message;
    }
    
    public void setMessage(String message) {
        this.message = message;
    }
    
    public Object getDetails() {
        return details;
    }
    
    public void setDetails(Object details) {
        this.details = details;
    }
}
```

### 2.2 具体异常类

#### 2.2.1 认证异常

```java
/**
 * 未认证异常（401）
 */
public class UnauthorizedException extends ApiException {
    
    public UnauthorizedException() {
        super(401, "未登录或登录已过期");
    }
    
    public UnauthorizedException(String message) {
        super(401, message);
    }
}
```

#### 2.2.2 权限异常

```java
/**
 * 无权限异常（403）
 */
public class ForbiddenException extends ApiException {
    
    public ForbiddenException() {
        super(403, "权限不足");
    }
    
    public ForbiddenException(String message) {
        super(403, message);
    }
    
    public ForbiddenException(String message, String permission) {
        super(403, message, permission);
    }
}
```

#### 2.2.3 资源不存在异常

```java
/**
 * 资源不存在异常（404）
 */
public class NotFoundException extends ApiException {
    
    public NotFoundException(String resourceName) {
        super(404, String.format("%s 不存在", resourceName));
    }
    
    public NotFoundException(String resourceName, Object resourceId) {
        super(404, String.format("%s [%s] 不存在", resourceName, resourceId));
    }
}
```

#### 2.2.4 参数验证异常

```java
/**
 * 参数验证异常（400）
 */
public class ValidationException extends ApiException {
    
    /**
     * 验证错误列表
     */
    private List<FieldError> errors;
    
    public ValidationException(String message) {
        super(400, message);
    }
    
    public ValidationException(String message, List<FieldError> errors) {
        super(400, message, errors);
        this.errors = errors;
    }
    
    public List<FieldError> getErrors() {
        return errors;
    }
    
    public void setErrors(List<FieldError> errors) {
        this.errors = errors;
    }
}

/**
 * 字段错误
 */
@Data
public class FieldError {
    
    /**
     * 字段名
     */
    private String field;
    
    /**
     * 错误消息
     */
    private String message;
    
    /**
     * 错误值
     */
    private Object rejectedValue;
    
    public FieldError(String field, String message) {
        this.field = field;
        this.message = message;
    }
    
    public FieldError(String field, String message, Object rejectedValue) {
        this.field = field;
        this.message = message;
        this.rejectedValue = rejectedValue;
    }
}
```

#### 2.2.5 业务异常

```java
/**
 * 业务异常
 */
public class BusinessException extends ApiException {
    
    public BusinessException(String message) {
        super(500, message);
    }
    
    public BusinessException(String message, Throwable cause) {
        super(message, cause);
    }
    
    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getCode(), errorCode.getMessage());
    }
    
    public BusinessException(ErrorCode errorCode, Object... args) {
        super(errorCode.getCode(), String.format(errorCode.getMessage(), args));
    }
}
```

#### 2.2.6 限流异常

```java
/**
 * 请求限流异常（429）
 */
public class RateLimitException extends ApiException {
    
    public RateLimitException() {
        super(429, "请求过于频繁，请稍后再试");
    }
    
    public RateLimitException(String message) {
        super(429, message);
    }
    
    public RateLimitException(int retryAfterSeconds) {
        super(429, String.format("请求过于频繁，请在 %d 秒后重试", retryAfterSeconds));
    }
}
```

### 2.3 错误码枚举

```java
/**
 * 错误码枚举
 */
public enum ErrorCode {
    
    // 通用错误码 (1000-1999)
    SUCCESS(0, "操作成功"),
    UNKNOWN_ERROR(1000, "未知错误"),
    SYSTEM_ERROR(1001, "系统错误"),
    PARAM_ERROR(1002, "参数错误"),
    OPERATION_FAILED(1003, "操作失败"),
    
    // 认证授权错误码 (2000-2999)
    UNAUTHORIZED(2000, "未登录或登录已过期"),
    FORBIDDEN(2001, "权限不足"),
    TOKEN_INVALID(2002, "Token 无效"),
    TOKEN_EXPIRED(2003, "Token 已过期"),
    PASSWORD_ERROR(2004, "密码错误"),
    USER_DISABLED(2005, "用户已被禁用"),
    USER_NOT_FOUND(2006, "用户不存在"),
    
    // 资源错误码 (3000-3999)
    RESOURCE_NOT_FOUND(3000, "资源不存在"),
    RESOURCE_ALREADY_EXISTS(3001, "资源已存在"),
    RESOURCE_LOCKED(3002, "资源已被锁定"),
    
    // 集群相关错误码 (4000-4999)
    CLUSTER_NOT_FOUND(4000, "集群不存在"),
    CLUSTER_NAME_EXISTS(4001, "集群名称已存在"),
    CLUSTER_CANNOT_DELETE(4002, "集群无法删除，存在关联服务"),
    
    // 服务相关错误码 (5000-5999)
    SERVICE_NOT_FOUND(5000, "服务不存在"),
    SERVICE_ALREADY_INSTALLED(5001, "服务已安装"),
    SERVICE_START_FAILED(5002, "服务启动失败"),
    SERVICE_STOP_FAILED(5003, "服务停止失败"),
    
    // 主机相关错误码 (6000-6999)
    HOST_NOT_FOUND(6000, "主机不存在"),
    HOST_ALREADY_EXISTS(6001, "主机已存在"),
    HOST_CONNECTION_FAILED(6002, "主机连接失败"),
    HOST_CANNOT_DELETE(6003, "主机无法删除，存在关联服务"),
    
    // 配置相关错误码 (7000-7999)
    CONFIG_NOT_FOUND(7000, "配置不存在"),
    CONFIG_VALIDATE_FAILED(7001, "配置验证失败"),
    CONFIG_APPLY_FAILED(7002, "配置应用失败"),
    
    // 告警相关错误码 (8000-8999)
    ALERT_NOT_FOUND(8000, "告警不存在"),
    ALERT_GROUP_NOT_FOUND(8001, "告警组不存在"),
    ALERT_RULE_INVALID(8002, "告警规则无效");
    
    private final Integer code;
    private final String message;
    
    ErrorCode(Integer code, String message) {
        this.code = code;
        this.message = message;
    }
    
    public Integer getCode() {
        return code;
    }
    
    public String getMessage() {
        return message;
    }
}
```

## 三、全局异常处理器

### 3.1 核心异常处理器

```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    /**
     * 处理 API 异常
     */
    @ExceptionHandler(ApiException.class)
    public Result handleApiException(ApiException e) {
        log.error("API异常: code={}, message={}", e.getCode(), e.getMessage());
        return Result.error(e.getCode(), e.getMessage(), e.getDetails());
    }
    
    /**
     * 处理未认证异常
     */
    @ExceptionHandler(UnauthorizedException.class)
    @ResponseStatus(HttpStatus.UNAUTHORIZED)
    public Result handleUnauthorizedException(UnauthorizedException e) {
        log.warn("未认证: {}", e.getMessage());
        return Result.error(401, e.getMessage());
    }
    
    /**
     * 处理无权限异常
     */
    @ExceptionHandler(ForbiddenException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public Result handleForbiddenException(ForbiddenException e) {
        log.warn("权限不足: {}", e.getMessage());
        return Result.error(403, e.getMessage());
    }
    
    /**
     * 处理资源不存在异常
     */
    @ExceptionHandler(NotFoundException.class)
    @ResponseStatus(HttpStatus.NOT_FOUND)
    public Result handleNotFoundException(NotFoundException e) {
        log.warn("资源不存在: {}", e.getMessage());
        return Result.error(404, e.getMessage());
    }
    
    /**
     * 处理参数验证异常
     */
    @ExceptionHandler(ValidationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Result handleValidationException(ValidationException e) {
        log.warn("参数验证失败: {}", e.getMessage());
        return Result.error(400, e.getMessage(), e.getErrors());
    }
    
    /**
     * 处理限流异常
     */
    @ExceptionHandler(RateLimitException.class)
    @ResponseStatus(HttpStatus.TOO_MANY_REQUESTS)
    public Result handleRateLimitException(RateLimitException e) {
        log.warn("请求限流: {}", e.getMessage());
        return Result.error(429, e.getMessage());
    }
    
    /**
     * 处理参数校验异常（@Valid）
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Result handleMethodArgumentNotValidException(MethodArgumentNotValidException e) {
        log.warn("参数校验失败: {}", e.getMessage());
        
        List<FieldError> errors = new ArrayList<>();
        e.getBindingResult().getFieldErrors().forEach(error -> {
            errors.add(new FieldError(
                error.getField(),
                error.getDefaultMessage(),
                error.getRejectedValue()
            ));
        });
        
        return Result.error(400, "参数校验失败", errors);
    }
    
    /**
     * 处理参数绑定异常
     */
    @ExceptionHandler(BindException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Result handleBindException(BindException e) {
        log.warn("参数绑定失败: {}", e.getMessage());
        
        List<FieldError> errors = new ArrayList<>();
        e.getBindingResult().getFieldErrors().forEach(error -> {
            errors.add(new FieldError(
                error.getField(),
                error.getDefaultMessage(),
                error.getRejectedValue()
            ));
        });
        
        return Result.error(400, "参数绑定失败", errors);
    }
    
    /**
     * 处理约束违反异常（@Validated）
     */
    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public Result handleConstraintViolationException(ConstraintViolationException e) {
        log.warn("约束验证失败: {}", e.getMessage());
        
        List<String> errors = new ArrayList<>();
        e.getConstraintViolations().forEach(violation -> {
            errors.add(violation.getPropertyPath() + ": " + violation.getMessage());
        });
        
        return Result.error(400, "约束验证失败", errors);
    }
    
    /**
     * 处理 HTTP 请求方法不支持异常
     */
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED)
    public Result handleHttpRequestMethodNotSupportedException(
        HttpRequestMethodNotSupportedException e
    ) {
        log.warn("请求方法不支持: {}", e.getMessage());
        return Result.error(405, "请求方法不支持: " + e.getMethod());
    }
    
    /**
     * 处理 HTTP 媒体类型不支持异常
     */
    @ExceptionHandler(HttpMediaTypeNotSupportedException.class)
    @ResponseStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE)
    public Result handleHttpMediaTypeNotSupportedException(
        HttpMediaTypeNotSupportedException e
    ) {
        log.warn("媒体类型不支持: {}", e.getMessage());
        return Result.error(415, "媒体类型不支持: " + e.getContentType());
    }
    
    /**
     * 处理数据库异常
     */
    @ExceptionHandler(DataAccessException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result handleDataAccessException(DataAccessException e) {
        log.error("数据库异常: ", e);
        return Result.error(500, "数据库操作失败");
    }
    
    /**
     * 处理空指针异常
     */
    @ExceptionHandler(NullPointerException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result handleNullPointerException(NullPointerException e) {
        log.error("空指针异常: ", e);
        return Result.error(500, "系统内部错误");
    }
    
    /**
     * 处理类型转换异常
     */
    @ExceptionHandler(ClassCastException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result handleClassCastException(ClassCastException e) {
        log.error("类型转换异常: ", e);
        return Result.error(500, "数据类型错误");
    }
    
    /**
     * 处理数组越界异常
     */
    @ExceptionHandler(ArrayIndexOutOfBoundsException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result handleArrayIndexOutOfBoundsException(ArrayIndexOutOfBoundsException e) {
        log.error("数组越界异常: ", e);
        return Result.error(500, "系统内部错误");
    }
    
    /**
     * 处理通用运行时异常
     */
    @ExceptionHandler(RuntimeException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result handleRuntimeException(RuntimeException e) {
        log.error("运行时异常: ", e);
        return Result.error(500, "系统内部错误");
    }
    
    /**
     * 处理未知异常
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public Result handleException(Exception e) {
        log.error("未知异常: ", e);
        return Result.error(500, "系统内部错误，请联系管理员");
    }
}
```

### 3.2 异常响应格式

```java
/**
 * 统一响应对象
 */
@Data
public class Result<T> implements Serializable {
    
    /**
     * 响应码（0 表示成功）
     */
    private Integer code;
    
    /**
     * 响应消息
     */
    private String msg;
    
    /**
     * 响应数据
     */
    private T data;
    
    /**
     * 时间戳
     */
    private Long timestamp;
    
    /**
     * 请求 ID
     */
    private String requestId;
    
    public Result() {
        this.timestamp = System.currentTimeMillis();
    }
    
    public Result(Integer code, String msg) {
        this();
        this.code = code;
        this.msg = msg;
    }
    
    public Result(Integer code, String msg, T data) {
        this(code, msg);
        this.data = data;
    }
    
    /**
     * 成功响应
     */
    public static <T> Result<T> success() {
        return new Result<>(0, "操作成功");
    }
    
    public static <T> Result<T> success(T data) {
        return new Result<>(0, "操作成功", data);
    }
    
    public static <T> Result<T> success(String msg, T data) {
        return new Result<>(0, msg, data);
    }
    
    /**
     * 失败响应
     */
    public static <T> Result<T> error(String msg) {
        return new Result<>(500, msg);
    }
    
    public static <T> Result<T> error(Integer code, String msg) {
        return new Result<>(code, msg);
    }
    
    public static <T> Result<T> error(Integer code, String msg, T data) {
        return new Result<>(code, msg, data);
    }
    
    public static <T> Result<T> error(ErrorCode errorCode) {
        return new Result<>(errorCode.getCode(), errorCode.getMessage());
    }
    
    /**
     * 判断是否成功
     */
    public boolean isSuccess() {
        return this.code != null && this.code == 0;
    }
}
```

### 3.3 异常响应示例

#### 成功响应：
```json
{
  "code": 0,
  "msg": "操作成功",
  "data": {
    "id": 1,
    "name": "test-cluster"
  },
  "timestamp": 1700123456789,
  "requestId": "a1b2c3d4e5f6"
}
```

#### 业务异常响应：
```json
{
  "code": 4001,
  "msg": "集群名称已存在",
  "data": null,
  "timestamp": 1700123456789,
  "requestId": "a1b2c3d4e5f6"
}
```

#### 参数验证失败响应：
```json
{
  "code": 400,
  "msg": "参数验证失败",
  "data": [
    {
      "field": "clusterName",
      "message": "集群名称不能为空",
      "rejectedValue": null
    },
    {
      "field": "clusterCode",
      "message": "集群编码长度必须在 3-20 之间",
      "rejectedValue": "ab"
    }
  ],
  "timestamp": 1700123456789,
  "requestId": "a1b2c3d4e5f6"
}
```

## 四、参数验证

### 4.1 Bean Validation 注解

```java
@Data
public class ClusterCreateRequest {
    
    @NotBlank(message = "集群名称不能为空")
    @Length(min = 2, max = 50, message = "集群名称长度必须在 2-50 之间")
    private String clusterName;
    
    @NotBlank(message = "集群编码不能为空")
    @Pattern(regexp = "^[a-zA-Z0-9_-]{3,20}$", message = "集群编码格式不正确")
    private String clusterCode;
    
    @NotNull(message = "集群类型不能为空")
    private Integer clusterType;
    
    @NotEmpty(message = "集群主机列表不能为空")
    @Size(min = 1, max = 1000, message = "集群主机数量必须在 1-1000 之间")
    private List<String> hostnames;
    
    @Min(value = 1, message = "副本数不能小于 1")
    @Max(value = 10, message = "副本数不能大于 10")
    private Integer replicationFactor;
    
    @Email(message = "邮箱格式不正确")
    private String contactEmail;
    
    @URL(message = "URL 格式不正确")
    private String homepageUrl;
}
```

### 4.2 自定义验证注解

```java
/**
 * IP 地址验证注解
 */
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = IpAddressValidator.class)
public @interface IpAddress {
    
    String message() default "IP 地址格式不正确";
    
    Class<?>[] groups() default {};
    
    Class<? extends Payload>[] payload() default {};
}

/**
 * IP 地址验证器
 */
public class IpAddressValidator implements ConstraintValidator<IpAddress, String> {
    
    private static final Pattern IP_PATTERN = Pattern.compile(
        "^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$"
    );
    
    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (value == null || value.isEmpty()) {
            return true; // 允许为空，使用 @NotNull 单独验证
        }
        return IP_PATTERN.matcher(value).matches();
    }
}

/**
 * 使用示例
 */
@Data
public class HostAddRequest {
    
    @NotBlank(message = "主机名不能为空")
    private String hostname;
    
    @IpAddress(message = "IP 地址格式不正确")
    private String ipAddress;
}
```

### 4.3 分组验证

```java
/**
 * 验证分组接口
 */
public interface ValidationGroups {
    interface Create {}
    interface Update {}
    interface Delete {}
}

/**
 * 使用分组验证
 */
@Data
public class UserRequest {
    
    @Null(groups = Create.class, message = "创建时 ID 必须为空")
    @NotNull(groups = Update.class, message = "更新时 ID 不能为空")
    private Integer id;
    
    @NotBlank(groups = {Create.class, Update.class}, message = "用户名不能为空")
    private String username;
    
    @NotBlank(groups = Create.class, message = "密码不能为空")
    private String password;
}

/**
 * Controller 中使用分组验证
 */
@RestController
@RequestMapping("api/user")
public class UserController {
    
    @PostMapping("/create")
    public Result create(@Validated(ValidationGroups.Create.class) @RequestBody UserRequest request) {
        // 创建用户
    }
    
    @PutMapping("/update")
    public Result update(@Validated(ValidationGroups.Update.class) @RequestBody UserRequest request) {
        // 更新用户
    }
}
```

## 五、异常日志记录

### 5.1 异常日志配置

```java
@Aspect
@Component
@Slf4j
public class ExceptionLogAspect {
    
    @Autowired
    private ExceptionLogService exceptionLogService;
    
    /**
     * 环绕通知：记录异常日志
     */
    @Around("@annotation(org.springframework.web.bind.annotation.RequestMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.PostMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.GetMapping)")
    public Object logException(ProceedingJoinPoint joinPoint) throws Throwable {
        try {
            return joinPoint.proceed();
        } catch (Exception e) {
            // 记录异常日志
            logExceptionDetails(joinPoint, e);
            throw e;
        }
    }
    
    /**
     * 记录异常详情
     */
    private void logExceptionDetails(ProceedingJoinPoint joinPoint, Exception e) {
        try {
            ExceptionLog exceptionLog = new ExceptionLog();
            
            // 异常信息
            exceptionLog.setExceptionType(e.getClass().getName());
            exceptionLog.setExceptionMessage(e.getMessage());
            exceptionLog.setStackTrace(getStackTrace(e));
            
            // 请求信息
            HttpServletRequest request = getCurrentRequest();
            if (request != null) {
                exceptionLog.setRequestUri(request.getRequestURI());
                exceptionLog.setRequestMethod(request.getMethod());
                exceptionLog.setRequestParams(JsonUtils.toJson(request.getParameterMap()));
                exceptionLog.setClientIp(getClientIp(request));
            }
            
            // 方法信息
            exceptionLog.setClassName(joinPoint.getTarget().getClass().getName());
            exceptionLog.setMethodName(joinPoint.getSignature().getName());
            exceptionLog.setMethodArgs(JsonUtils.toJson(joinPoint.getArgs()));
            
            // 用户信息
            Integer userId = UserContext.getCurrentUserId();
            if (userId != null) {
                exceptionLog.setUserId(userId);
                exceptionLog.setUsername(UserContext.getCurrentUsername());
            }
            
            exceptionLog.setCreateTime(LocalDateTime.now());
            
            // 异步保存日志
            exceptionLogService.saveAsync(exceptionLog);
            
        } catch (Exception ex) {
            log.error("记录异常日志失败: ", ex);
        }
    }
    
    /**
     * 获取堆栈跟踪
     */
    private String getStackTrace(Exception e) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        e.printStackTrace(pw);
        return sw.toString();
    }
}
```

### 5.2 异常日志实体

```java
@Data
@TableName("t_exception_log")
public class ExceptionLog {
    
    @TableId(type = IdType.AUTO)
    private Long id;
    
    /**
     * 异常类型
     */
    private String exceptionType;
    
    /**
     * 异常消息
     */
    private String exceptionMessage;
    
    /**
     * 堆栈跟踪
     */
    @Column(columnDefinition = "TEXT")
    private String stackTrace;
    
    /**
     * 请求 URI
     */
    private String requestUri;
    
    /**
     * 请求方法
     */
    private String requestMethod;
    
    /**
     * 请求参数
     */
    @Column(columnDefinition = "TEXT")
    private String requestParams;
    
    /**
     * 客户端 IP
     */
    private String clientIp;
    
    /**
     * 类名
     */
    private String className;
    
    /**
     * 方法名
     */
    private String methodName;
    
    /**
     * 方法参数
     */
    @Column(columnDefinition = "TEXT")
    private String methodArgs;
    
    /**
     * 用户 ID
     */
    private Integer userId;
    
    /**
     * 用户名
     */
    private String username;
    
    /**
     * 创建时间
     */
    private LocalDateTime createTime;
}
```

## 六、异常处理最佳实践

### 6.1 异常处理原则

1. **明确异常类型**: 使用具体的异常类，而不是通用 Exception
2. **异常信息友好**: 提供清晰的错误消息，帮助定位问题
3. **不吃异常**: 捕获异常后必须处理或重新抛出
4. **日志记录**: 记录异常的完整信息，包括堆栈跟踪
5. **避免过度捕获**: 只捕获能够处理的异常

### 6.2 异常抛出示例

```java
@Service
public class ClusterInfoService {
    
    /**
     * 良好的异常处理示例
     */
    public ClusterInfoEntity getClusterById(Integer clusterId) {
        // 1. 参数验证
        if (clusterId == null || clusterId <= 0) {
            throw new ValidationException("集群 ID 不能为空或小于等于 0");
        }
        
        // 2. 查询数据
        ClusterInfoEntity cluster = clusterMapper.selectById(clusterId);
        
        // 3. 结果验证
        if (cluster == null) {
            throw new NotFoundException("集群", clusterId);
        }
        
        return cluster;
    }
    
    /**
     * 业务异常处理示例
     */
    public void createCluster(ClusterCreateRequest request) {
        // 1. 检查集群名称是否已存在
        ClusterInfoEntity exists = clusterMapper.selectByName(request.getClusterName());
        if (exists != null) {
            throw new BusinessException(ErrorCode.CLUSTER_NAME_EXISTS);
        }
        
        // 2. 创建集群
        try {
            ClusterInfoEntity cluster = new ClusterInfoEntity();
            BeanUtils.copyProperties(request, cluster);
            clusterMapper.insert(cluster);
            
        } catch (DataAccessException e) {
            log.error("创建集群失败: ", e);
            throw new BusinessException("创建集群失败: " + e.getMessage(), e);
        }
    }
}
```

### 6.3 异常转换

```java
@Service
public class ServiceWrapper {
    
    /**
     * 将底层异常转换为业务异常
     */
    public void executeWithExceptionTranslation(Runnable task) {
        try {
            task.run();
        } catch (DataAccessException e) {
            // 数据库异常
            throw new BusinessException("数据库操作失败", e);
        } catch (IOException e) {
            // IO 异常
            throw new BusinessException("文件操作失败", e);
        } catch (TimeoutException e) {
            // 超时异常
            throw new BusinessException("操作超时", e);
        } catch (Exception e) {
            // 其他异常
            throw new BusinessException("系统错误", e);
        }
    }
}
```

## 七、前端错误处理

### 7.1 Axios 拦截器

```javascript
// api/request.js
import axios from 'axios'
import { Message } from 'element-ui'
import router from '@/router'

// 创建 axios 实例
const service = axios.create({
  baseURL: process.env.VUE_APP_BASE_API,
  timeout: 30000
})

// 响应拦截器
service.interceptors.response.use(
  response => {
    const res = response.data
    
    // 检查业务状态码
    if (res.code !== 0) {
      // 错误处理
      handleError(res)
      return Promise.reject(new Error(res.msg || '请求失败'))
    }
    
    return res.data
  },
  error => {
    console.error('请求错误:', error)
    handleHttpError(error)
    return Promise.reject(error)
  }
)

/**
 * 处理业务错误
 */
function handleError(res) {
  switch (res.code) {
    case 401:
      Message.error('登录已过期，请重新登录')
      router.push('/login')
      break
    case 403:
      Message.error('权限不足')
      break
    case 404:
      Message.error('请求的资源不存在')
      break
    case 429:
      Message.error('请求过于频繁，请稍后再试')
      break
    default:
      Message.error(res.msg || '操作失败')
  }
}

/**
 * 处理 HTTP 错误
 */
function handleHttpError(error) {
  if (error.response) {
    const status = error.response.status
    
    switch (status) {
      case 400:
        Message.error('请求参数错误')
        break
      case 401:
        Message.error('未授权，请重新登录')
        router.push('/login')
        break
      case 403:
        Message.error('拒绝访问')
        break
      case 404:
        Message.error('请求地址不存在')
        break
      case 500:
        Message.error('服务器内部错误')
        break
      case 502:
        Message.error('网关错误')
        break
      case 503:
        Message.error('服务不可用')
        break
      case 504:
        Message.error('网关超时')
        break
      default:
        Message.error(`请求失败: ${status}`)
    }
  } else if (error.request) {
    Message.error('网络错误，请检查网络连接')
  } else {
    Message.error('请求配置错误')
  }
}

export default service
```

## 八、总结

### 8.1 异常处理核心

DataSophon API 异常处理体系包括：

1. ✅ **分层异常**: 业务异常、系统异常、HTTP 异常分类清晰
2. ✅ **统一处理**: 全局异常处理器统一处理所有异常
3. ✅ **友好提示**: 清晰的错误消息和错误码
4. ✅ **参数验证**: Bean Validation 自动验证请求参数
5. ✅ **异常日志**: 完整记录异常信息，便于问题排查

### 8.2 技术亮点

1. **@RestControllerAdvice**: 统一异常处理
2. **自定义异常**: 细粒度异常分类
3. **错误码枚举**: 规范化错误码管理
4. **Bean Validation**: 自动参数验证
5. **异常日志**: AOP 切面记录异常日志

---

**文档版本**: v1.0  
**最后更新**: 2025-11-16  
**维护团队**: DataSophon 源码分析团队
