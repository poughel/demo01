# DataSophon API 配置管理详解

## 一、配置管理概述

### 1.1 模块定位

DataSophon API 模块的配置管理涵盖应用程序配置、服务配置、系统参数等多个方面，采用 Spring Boot 的配置体系，支持多环境配置和动态配置更新。

### 1.2 配置层次结构

```
配置管理
├── 应用程序配置
│   ├── application.yml (主配置文件)
│   ├── application-dev.yml (开发环境)
│   ├── application-test.yml (测试环境)
│   └── application-prod.yml (生产环境)
├── 服务配置
│   ├── 数据库配置
│   ├── Redis 配置
│   ├── Akka Actor 配置
│   └── 监控配置 (Prometheus)
├── 业务配置
│   ├── 服务元数据配置
│   ├── 告警规则配置
│   └── 权限配置
└── 外部配置
    ├── 环境变量
    ├── 配置中心 (可选)
    └── 命令行参数
```

## 二、主配置文件详解

### 2.1 application.yml 核心配置

#### 2.1.1 服务器配置

```yaml
# 服务器端口和上下文路径配置
server:
  port: 8080
  servlet:
    context-path: /
    session:
      timeout: 30m
  # Tomcat 配置
  tomcat:
    uri-encoding: UTF-8
    max-threads: 200
    max-connections: 10000
    accept-count: 100
    connection-timeout: 20000
  # 压缩配置
  compression:
    enabled: true
    mime-types: text/html,text/xml,text/plain,text/css,text/javascript,application/javascript,application/json
    min-response-size: 1024
```

**配置说明**:
- `port`: API 服务监听端口
- `max-threads`: Tomcat 最大工作线程数
- `max-connections`: 最大并发连接数
- `compression`: 启用 HTTP 响应压缩，减少网络传输

#### 2.1.2 Spring 框架配置

```yaml
spring:
  application:
    name: datasophon-api
  
  # Profile 激活
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
  
  # 数据源配置
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://${MYSQL_HOST:localhost}:${MYSQL_PORT:3306}/${MYSQL_DATABASE:datasophon}?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai&useSSL=false
    username: ${MYSQL_USERNAME:root}
    password: ${MYSQL_PASSWORD:datasophon}
    # 连接池配置
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      connection-test-query: SELECT 1
  
  # Redis 配置
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    database: ${REDIS_DATABASE:0}
    timeout: 3000
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5
        max-wait: 3000
  
  # 文件上传配置
  servlet:
    multipart:
      enabled: true
      max-file-size: 100MB
      max-request-size: 100MB
      file-size-threshold: 2KB
  
  # Jackson JSON 配置
  jackson:
    time-zone: GMT+8
    date-format: yyyy-MM-dd HH:mm:ss
    serialization:
      write-dates-as-timestamps: false
      fail-on-empty-beans: false
    deserialization:
      fail-on-unknown-properties: false
```

**配置要点**:
1. **环境变量支持**: 使用 `${VAR:default}` 语法支持环境变量配置
2. **连接池优化**: HikariCP 连接池配置，适合高并发场景
3. **Redis**: 用于会话管理、缓存等
4. **文件上传**: 支持大文件上传（最大 100MB）

### 2.2 MyBatis 配置

```yaml
mybatis:
  # Mapper XML 文件位置
  mapper-locations: classpath*:mapper/**/*.xml
  # 类型别名包路径
  type-aliases-package: com.datasophon.domain.entity
  # MyBatis 配置
  configuration:
    # 驼峰命名转换
    map-underscore-to-camel-case: true
    # 日志实现
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
    # 缓存配置
    cache-enabled: true
    lazy-loading-enabled: false
    aggressive-lazy-loading: false
    # 自动映射行为
    auto-mapping-behavior: partial
    auto-mapping-unknown-column-behavior: warning
```

**MyBatis 配置说明**:

| 配置项 | 值 | 说明 |
|-------|-----|------|
| map-underscore-to-camel-case | true | 自动将数据库字段 `user_name` 映射为 `userName` |
| cache-enabled | true | 启用二级缓存 |
| lazy-loading-enabled | false | 禁用懒加载，避免 N+1 查询问题 |
| auto-mapping-behavior | partial | 自动映射部分字段 |

### 2.3 日志配置

#### 2.3.1 Logback 配置文件

```xml
<!-- logback-spring.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- 日志文件存储路径 -->
    <property name="LOG_PATH" value="${LOG_PATH:-/opt/datasophon/logs/api}"/>
    <property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"/>
    
    <!-- 控制台输出 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>
    
    <!-- 文件输出 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/datasophon-api.log</file>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <!-- 滚动策略 -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/datasophon-api.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>100MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>
    
    <!-- 错误日志单独记录 -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
        <file>${LOG_PATH}/datasophon-api-error.log</file>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/datasophon-api-error.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>90</maxHistory>
        </rollingPolicy>
    </appender>
    
    <!-- 异步日志 -->
    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <discardingThreshold>0</discardingThreshold>
        <queueSize>512</queueSize>
        <appender-ref ref="FILE"/>
    </appender>
    
    <!-- 日志级别配置 -->
    <logger name="com.datasophon" level="INFO"/>
    <logger name="org.springframework" level="WARN"/>
    <logger name="org.mybatis" level="WARN"/>
    <logger name="com.zaxxer.hikari" level="WARN"/>
    <logger name="org.apache.kafka" level="WARN"/>
    
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="ASYNC_FILE"/>
        <appender-ref ref="ERROR_FILE"/>
    </root>
</configuration>
```

**日志策略**:
1. **滚动策略**: 按日期和大小滚动，单文件最大 100MB
2. **保留策略**: 普通日志保留 30 天，错误日志保留 90 天
3. **异步写入**: 使用异步 Appender 提升性能
4. **错误日志**: 单独记录 ERROR 级别日志，便于问题排查

### 2.4 Akka Actor 配置

```yaml
# Akka Actor 系统配置
akka:
  actor:
    provider: remote
    default-dispatcher:
      type: Dispatcher
      executor: fork-join-executor
      fork-join-executor:
        parallelism-min: 8
        parallelism-factor: 2.0
        parallelism-max: 64
      throughput: 5
    
  remote:
    artery:
      enabled: on
      transport: tcp
      canonical:
        hostname: ${AKKA_HOST:localhost}
        port: ${AKKA_PORT:2551}
      bind:
        hostname: ${AKKA_BIND_HOST:0.0.0.0}
        port: ${AKKA_BIND_PORT:2551}
    
  cluster:
    seed-nodes: [
      "akka://datasophon@${SEED_NODE_1:localhost}:2551",
      "akka://datasophon@${SEED_NODE_2:localhost}:2552"
    ]
    auto-down-unreachable-after: 10s
    retry-unsuccessful-join-after: 3s
```

**Akka 配置说明**:
- `fork-join-executor`: 使用 Fork/Join 线程池，适合 CPU 密集型任务
- `parallelism-max`: 最大并行度 64
- `remote.artery`: 使用 Artery 传输，性能更好
- `cluster.seed-nodes`: 集群种子节点列表

## 三、多环境配置

### 3.1 开发环境配置 (application-dev.yml)

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/datasophon_dev?useUnicode=true&characterEncoding=UTF-8
    username: root
    password: root
  
  redis:
    host: localhost
    port: 6379
    password: ""

# 开发环境开启 SQL 日志
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

# 开启调试日志
logging:
  level:
    com.datasophon: DEBUG
    org.springframework.web: DEBUG

# 开发环境关闭缓存
spring:
  cache:
    type: none
```

### 3.2 测试环境配置 (application-test.yml)

```yaml
spring:
  datasource:
    url: jdbc:mysql://test-mysql:3306/datasophon_test?useUnicode=true&characterEncoding=UTF-8
    username: datasophon_test
    password: ${MYSQL_PASSWORD}
  
  redis:
    host: test-redis
    port: 6379
    password: ${REDIS_PASSWORD}

logging:
  level:
    com.datasophon: INFO
```

### 3.3 生产环境配置 (application-prod.yml)

```yaml
spring:
  datasource:
    url: jdbc:mysql://${MYSQL_HOST}:3306/${MYSQL_DATABASE}?useUnicode=true&characterEncoding=UTF-8&useSSL=true
    username: ${MYSQL_USERNAME}
    password: ${MYSQL_PASSWORD}
    hikari:
      maximum-pool-size: 50
      minimum-idle: 10
  
  redis:
    host: ${REDIS_HOST}
    port: ${REDIS_PORT}
    password: ${REDIS_PASSWORD}
    lettuce:
      pool:
        max-active: 50

# 生产环境关闭 SQL 日志
mybatis:
  configuration:
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl

logging:
  level:
    com.datasophon: WARN
    root: WARN
```

**环境差异对比**:

| 配置项 | 开发环境 | 测试环境 | 生产环境 |
|-------|---------|---------|---------|
| 数据库连接池 | 20 | 30 | 50 |
| Redis 连接池 | 20 | 30 | 50 |
| 日志级别 | DEBUG | INFO | WARN |
| SQL 日志 | 控制台 | 文件 | 关闭 |
| 缓存 | 关闭 | 启用 | 启用 |

## 四、业务配置管理

### 4.1 服务配置管理 Controller

```java
@RestController
@RequestMapping("api/service/config")
public class ClusterServiceInstanceConfigController {
    
    @Autowired
    private ClusterServiceInstanceConfigService configService;
    
    /**
     * 获取服务配置列表
     */
    @RequestMapping("/list")
    public Result listConfigs(
        Integer clusterId,
        Integer serviceInstanceId,
        Integer page,
        Integer pageSize
    ) {
        Page<ClusterServiceInstanceConfig> configPage = 
            configService.listConfigs(clusterId, serviceInstanceId, page, pageSize);
        return Result.success(configPage);
    }
    
    /**
     * 获取配置详情
     */
    @RequestMapping("/get")
    public Result getConfig(Integer configId) {
        ClusterServiceInstanceConfig config = configService.getById(configId);
        return Result.success(config);
    }
    
    /**
     * 更新服务配置
     */
    @RequestMapping("/update")
    @UserPermission
    public Result updateConfig(@RequestBody ServiceConfigUpdateRequest request) {
        // 验证配置项
        configService.validateConfig(request);
        
        // 创建配置版本
        Integer configVersion = configService.createConfigVersion(request);
        
        // 更新配置
        configService.updateConfig(request);
        
        // 标记服务需要重启
        configService.markServiceNeedRestart(request.getServiceInstanceId());
        
        Map<String, Object> result = new HashMap<>();
        result.put("configVersion", configVersion);
        result.put("needRestart", true);
        
        return Result.success(result);
    }
    
    /**
     * 配置对比
     */
    @RequestMapping("/compare")
    public Result compareConfigs(Integer configId1, Integer configId2) {
        List<ConfigDifference> differences = 
            configService.compareConfigs(configId1, configId2);
        return Result.success(differences);
    }
    
    /**
     * 获取配置历史版本
     */
    @RequestMapping("/versions")
    public Result getConfigVersions(Integer serviceInstanceId) {
        List<ConfigVersion> versions = 
            configService.getConfigVersions(serviceInstanceId);
        return Result.success(versions);
    }
    
    /**
     * 回滚配置
     */
    @RequestMapping("/rollback")
    @UserPermission
    public Result rollbackConfig(Integer serviceInstanceId, Integer versionId) {
        configService.rollbackToVersion(serviceInstanceId, versionId);
        return Result.success();
    }
}
```

### 4.2 配置版本管理

#### 4.2.1 配置版本实体

```java
@Data
@TableName("t_config_version")
public class ConfigVersion {
    
    @TableId(type = IdType.AUTO)
    private Integer id;
    
    /**
     * 服务实例 ID
     */
    private Integer serviceInstanceId;
    
    /**
     * 版本号
     */
    private Integer version;
    
    /**
     * 配置内容（JSON 格式）
     */
    private String configContent;
    
    /**
     * 配置哈希值（用于快速对比）
     */
    private String configHash;
    
    /**
     * 创建人
     */
    private Integer createBy;
    
    /**
     * 创建时间
     */
    private LocalDateTime createTime;
    
    /**
     * 备注说明
     */
    private String remark;
    
    /**
     * 是否当前版本
     */
    private Boolean isCurrent;
}
```

#### 4.2.2 配置版本服务

```java
@Service
public class ConfigVersionService {
    
    @Autowired
    private ConfigVersionMapper versionMapper;
    
    /**
     * 创建新版本
     */
    public Integer createVersion(Integer serviceInstanceId, Map<String, String> configs) {
        // 获取当前最大版本号
        Integer maxVersion = versionMapper.getMaxVersion(serviceInstanceId);
        Integer newVersion = (maxVersion == null ? 1 : maxVersion + 1);
        
        // 计算配置哈希
        String configJson = JsonUtils.toJson(configs);
        String configHash = DigestUtils.md5Hex(configJson);
        
        // 检查是否与上一版本相同
        ConfigVersion lastVersion = versionMapper.getLatestVersion(serviceInstanceId);
        if (lastVersion != null && lastVersion.getConfigHash().equals(configHash)) {
            return lastVersion.getVersion();
        }
        
        // 创建新版本
        ConfigVersion version = new ConfigVersion();
        version.setServiceInstanceId(serviceInstanceId);
        version.setVersion(newVersion);
        version.setConfigContent(configJson);
        version.setConfigHash(configHash);
        version.setCreateTime(LocalDateTime.now());
        version.setIsCurrent(true);
        
        versionMapper.insert(version);
        
        // 将其他版本标记为非当前
        versionMapper.markOthersAsNotCurrent(serviceInstanceId, version.getId());
        
        return newVersion;
    }
    
    /**
     * 对比两个版本
     */
    public List<ConfigDifference> compareVersions(Integer versionId1, Integer versionId2) {
        ConfigVersion v1 = versionMapper.selectById(versionId1);
        ConfigVersion v2 = versionMapper.selectById(versionId2);
        
        Map<String, String> config1 = JsonUtils.fromJson(v1.getConfigContent(), Map.class);
        Map<String, String> config2 = JsonUtils.fromJson(v2.getConfigContent(), Map.class);
        
        return ConfigComparator.compare(config1, config2);
    }
}
```

### 4.3 配置模板管理

#### 4.3.1 配置模板

```java
@Data
public class ConfigTemplate {
    
    /**
     * 配置项名称
     */
    private String name;
    
    /**
     * 配置项显示名称
     */
    private String label;
    
    /**
     * 配置项类型
     */
    private String type; // string, number, boolean, select, textarea
    
    /**
     * 默认值
     */
    private String defaultValue;
    
    /**
     * 是否必填
     */
    private Boolean required;
    
    /**
     * 验证规则
     */
    private String validationRule;
    
    /**
     * 配置说明
     */
    private String description;
    
    /**
     * 配置分组
     */
    private String group;
    
    /**
     * 是否需要重启
     */
    private Boolean needRestart;
    
    /**
     * 可选值列表（type=select 时使用）
     */
    private List<String> options;
}
```

#### 4.3.2 HDFS 配置模板示例

```java
public class HdfsConfigTemplate {
    
    public static List<ConfigTemplate> getTemplates() {
        List<ConfigTemplate> templates = new ArrayList<>();
        
        // NameNode 堆内存
        templates.add(ConfigTemplate.builder()
            .name("namenode.heap.size")
            .label("NameNode 堆内存")
            .type("number")
            .defaultValue("4096")
            .required(true)
            .validationRule("min:1024,max:65536")
            .description("NameNode JVM 堆内存大小（MB）")
            .group("内存配置")
            .needRestart(true)
            .build());
        
        // DataNode 堆内存
        templates.add(ConfigTemplate.builder()
            .name("datanode.heap.size")
            .label("DataNode 堆内存")
            .type("number")
            .defaultValue("2048")
            .required(true)
            .validationRule("min:512,max:32768")
            .description("DataNode JVM 堆内存大小（MB）")
            .group("内存配置")
            .needRestart(true)
            .build());
        
        // 副本数
        templates.add(ConfigTemplate.builder()
            .name("dfs.replication")
            .label("默认副本数")
            .type("select")
            .defaultValue("3")
            .required(true)
            .options(Arrays.asList("1", "2", "3", "4", "5"))
            .description("HDFS 文件默认副本数")
            .group("存储配置")
            .needRestart(false)
            .build());
        
        // 块大小
        templates.add(ConfigTemplate.builder()
            .name("dfs.blocksize")
            .label("数据块大小")
            .type("select")
            .defaultValue("134217728")
            .required(true)
            .options(Arrays.asList("67108864", "134217728", "268435456"))
            .description("HDFS 数据块大小（字节）")
            .group("存储配置")
            .needRestart(false)
            .build());
        
        return templates;
    }
}
```

## 五、配置加载与优先级

### 5.1 配置加载顺序

Spring Boot 按以下顺序加载配置（后面的会覆盖前面的）：

```
1. 默认属性（SpringApplication.setDefaultProperties）
2. @Configuration 类上的 @PropertySource
3. 配置文件 (application.yml)
4. 配置文件 (application-{profile}.yml)
5. 操作系统环境变量
6. Java 系统属性 (System.getProperties())
7. JNDI 属性
8. 命令行参数
```

### 5.2 配置加载工具类

```java
@Component
public class ConfigLoader {
    
    @Autowired
    private Environment environment;
    
    /**
     * 获取配置值（支持多种类型）
     */
    public <T> T getConfig(String key, Class<T> type, T defaultValue) {
        String value = environment.getProperty(key);
        if (value == null) {
            return defaultValue;
        }
        
        return convertValue(value, type);
    }
    
    /**
     * 获取必需的配置（不存在则抛异常）
     */
    public String getRequiredConfig(String key) {
        String value = environment.getProperty(key);
        if (value == null) {
            throw new ConfigException("Required config not found: " + key);
        }
        return value;
    }
    
    /**
     * 获取配置列表
     */
    public List<String> getConfigList(String key, String delimiter) {
        String value = environment.getProperty(key);
        if (value == null) {
            return Collections.emptyList();
        }
        return Arrays.asList(value.split(delimiter));
    }
    
    /**
     * 获取当前激活的 Profile
     */
    public String[] getActiveProfiles() {
        return environment.getActiveProfiles();
    }
}
```

### 5.3 动态配置更新

```java
@Component
public class DynamicConfigService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    private static final String CONFIG_PREFIX = "datasophon:config:";
    
    /**
     * 保存配置到 Redis
     */
    public void saveConfig(String key, String value) {
        String redisKey = CONFIG_PREFIX + key;
        redisTemplate.opsForValue().set(redisKey, value);
        
        // 发布配置更新事件
        publishConfigChangeEvent(key, value);
    }
    
    /**
     * 从 Redis 获取配置
     */
    public String getConfig(String key) {
        String redisKey = CONFIG_PREFIX + key;
        return redisTemplate.opsForValue().get(redisKey);
    }
    
    /**
     * 发布配置变更事件
     */
    private void publishConfigChangeEvent(String key, String value) {
        ConfigChangeEvent event = new ConfigChangeEvent(key, value);
        redisTemplate.convertAndSend("config:change", JsonUtils.toJson(event));
    }
    
    /**
     * 监听配置变更
     */
    @RedisListener(topics = "config:change")
    public void onConfigChange(String message) {
        ConfigChangeEvent event = JsonUtils.fromJson(message, ConfigChangeEvent.class);
        
        // 触发配置刷新
        refreshConfig(event.getKey(), event.getValue());
        
        log.info("Config changed: {} = {}", event.getKey(), event.getValue());
    }
}
```

## 六、配置验证与安全

### 6.1 配置验证

```java
@Component
public class ConfigValidator {
    
    /**
     * 验证数据库连接配置
     */
    public void validateDatabaseConfig() {
        String url = environment.getProperty("spring.datasource.url");
        String username = environment.getProperty("spring.datasource.username");
        String password = environment.getProperty("spring.datasource.password");
        
        if (StringUtils.isEmpty(url) || StringUtils.isEmpty(username)) {
            throw new ConfigException("Database configuration is incomplete");
        }
        
        // 测试数据库连接
        try (Connection conn = DriverManager.getConnection(url, username, password)) {
            log.info("Database connection test successful");
        } catch (SQLException e) {
            throw new ConfigException("Database connection failed: " + e.getMessage());
        }
    }
    
    /**
     * 验证 Akka 配置
     */
    public void validateAkkaConfig() {
        String hostname = environment.getProperty("akka.remote.artery.canonical.hostname");
        Integer port = environment.getProperty("akka.remote.artery.canonical.port", Integer.class);
        
        if (StringUtils.isEmpty(hostname) || port == null) {
            throw new ConfigException("Akka configuration is incomplete");
        }
        
        // 验证端口可用性
        if (port < 1024 || port > 65535) {
            throw new ConfigException("Invalid Akka port: " + port);
        }
    }
}
```

### 6.2 敏感配置加密

```java
@Component
public class ConfigEncryption {
    
    private static final String ALGORITHM = "AES";
    private static final String TRANSFORMATION = "AES/ECB/PKCS5Padding";
    
    @Value("${config.encryption.key}")
    private String encryptionKey;
    
    /**
     * 加密敏感配置
     */
    public String encrypt(String plainText) throws Exception {
        SecretKeySpec keySpec = new SecretKeySpec(
            encryptionKey.getBytes(StandardCharsets.UTF_8), 
            ALGORITHM
        );
        
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        
        byte[] encrypted = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    /**
     * 解密敏感配置
     */
    public String decrypt(String encryptedText) throws Exception {
        SecretKeySpec keySpec = new SecretKeySpec(
            encryptionKey.getBytes(StandardCharsets.UTF_8),
            ALGORITHM
        );
        
        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        
        byte[] decrypted = cipher.doFinal(Base64.getDecoder().decode(encryptedText));
        return new String(decrypted, StandardCharsets.UTF_8);
    }
}
```

使用示例：
```yaml
spring:
  datasource:
    password: ENC(8x7KfP2QmN9vL3dR5tY6hA==)
```

## 七、最佳实践

### 7.1 配置管理建议

1. **环境分离**: 不同环境使用不同的配置文件
2. **敏感信息**: 密码等敏感信息使用环境变量或加密存储
3. **配置验证**: 启动时验证关键配置项
4. **版本控制**: 配置文件纳入版本控制，但排除敏感信息
5. **文档完善**: 为每个配置项添加注释说明

### 7.2 配置优化建议

1. **连接池**: 根据负载合理配置数据库和 Redis 连接池
2. **线程池**: Tomcat 和 Akka 线程池根据 CPU 核心数配置
3. **缓存**: 生产环境启用缓存，开发环境可关闭
4. **日志**: 生产环境降低日志级别，避免性能影响
5. **压缩**: 启用 HTTP 响应压缩，减少网络传输

## 八、总结

### 8.1 配置管理核心要点

1. ✅ **分层设计**: 应用配置、服务配置、业务配置分离
2. ✅ **多环境支持**: 开发、测试、生产环境独立配置
3. ✅ **版本控制**: 配置变更记录和回滚支持
4. ✅ **安全加密**: 敏感配置加密存储
5. ✅ **动态更新**: 支持配置热更新（部分配置）

### 8.2 技术亮点

1. **Spring Boot**: 强大的配置管理能力
2. **多数据源**: 支持配置文件、环境变量、配置中心
3. **配置验证**: 启动时自动验证配置有效性
4. **热更新**: Redis 发布订阅实现配置动态更新

---

**文档版本**: v1.0  
**最后更新**: 2025-11-16  
**维护团队**: DataSophon 源码分析团队
