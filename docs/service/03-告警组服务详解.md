# 告警组服务详解 - Service 层完整分析

## 一、告警组服务概述

### 1.1 模块定位

告警组服务是 DataSophon 监控告警系统的核心组件，负责告警组的生命周期管理、告警规则配置、告警历史记录和告警指标管理。它位于 Service 层，连接 Controller 层和数据访问层，实现核心业务逻辑。

**模块路径**: `datasophon-service/src/main/java/com/datasophon/api/service/`

### 1.2 核心服务类

告警组管理涉及四个核心服务类：

```
告警组服务模块
├── AlertGroupService                    # 告警组管理服务
│   └── impl/AlertGroupServiceImpl       # 告警组服务实现
├── ClusterAlertRuleService              # 告警规则服务
│   └── impl/ClusterAlertRuleServiceImpl # 告警规则实现
├── ClusterAlertHistoryService           # 告警历史服务
│   └── impl/ClusterAlertHistoryServiceImpl # 告警历史实现
└── ClusterAlertQuotaService             # 告警指标服务
    └── impl/ClusterAlertQuotaServiceImpl  # 告警指标实现
```

### 1.3 服务间关系

```
┌─────────────────────────────────────────────────────────┐
│                    Controller 层                         │
│              AlertGroupController                        │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│                     Service 层                           │
│  ┌───────────────────┐      ┌────────────────────┐     │
│  │ AlertGroupService │◄────►│ ClusterAlertQuota  │     │
│  │                   │      │ Service            │     │
│  └─────────┬─────────┘      └────────────────────┘     │
│            │                                             │
│            ├──► ClusterAlertRuleService                 │
│            └──► ClusterAlertHistoryService              │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│                   Mapper 层 (MyBatis)                    │
│  AlertGroupMapper | ClusterAlertQuotaMapper             │
│  ClusterAlertRuleMapper | ClusterAlertHistoryMapper     │
└─────────────────────────────────────────────────────────┘
```

## 二、AlertGroupService - 告警组管理服务

### 2.1 服务接口定义

**文件位置**: `datasophon-service/src/main/java/com/datasophon/api/service/AlertGroupService.java`

```java
public interface AlertGroupService extends IService<AlertGroupEntity> {
    
    /**
     * 获取告警组列表（分页）
     * @param clusterId 集群ID
     * @param alertGroupName 告警组名称（模糊查询）
     * @param page 页码
     * @param pageSize 每页大小
     * @return 分页结果
     */
    Result getAlertGroupList(Integer clusterId, String alertGroupName, 
                            Integer page, Integer pageSize);
    
    /**
     * 保存告警组
     * @param alertGroup 告警组实体
     * @return 操作结果
     */
    Result saveAlertGroup(AlertGroupEntity alertGroup);
    
    /**
     * 更新告警组
     * @param alertGroup 告警组实体
     * @return 操作结果
     */
    Result updateAlertGroup(AlertGroupEntity alertGroup);
    
    /**
     * 删除告警组（批量）
     * @param ids 告警组ID数组
     * @return 操作结果
     */
    Result deleteAlertGroup(Integer[] ids);
    
    /**
     * 根据ID获取告警组详情
     * @param id 告警组ID
     * @return 告警组实体
     */
    AlertGroupEntity getAlertGroupById(Integer id);
    
    /**
     * 获取集群的所有告警组
     * @param clusterId 集群ID
     * @return 告警组列表
     */
    List<AlertGroupEntity> getAlertGroupsByClusterId(Integer clusterId);
}
```

### 2.2 服务实现类详解

**文件位置**: `datasophon-service/src/main/java/com/datasophon/api/service/impl/AlertGroupServiceImpl.java`

#### 2.2.1 类结构与依赖

```java
@Service
public class AlertGroupServiceImpl extends ServiceImpl<AlertGroupMapper, AlertGroupEntity> 
    implements AlertGroupService {
    
    @Autowired
    private AlertGroupMapper alertGroupMapper;
    
    @Autowired
    private ClusterAlertQuotaService clusterAlertQuotaService;
    
    @Autowired
    private ClusterAlertGroupMapMapper clusterAlertGroupMapMapper;
    
    @Autowired
    private UserInfoService userInfoService;
    
    // Redis 缓存（如果使用）
    @Autowired(required = false)
    private RedisTemplate<String, Object> redisTemplate;
}
```

**依赖说明**:
- **AlertGroupMapper**: 数据访问层，操作告警组表
- **ClusterAlertQuotaService**: 告警指标服务，检查删除约束
- **ClusterAlertGroupMapMapper**: 集群告警组映射关系
- **UserInfoService**: 用户服务，验证通知人员
- **RedisTemplate**: 缓存服务，提升查询性能

#### 2.2.2 获取告警组列表

```java
@Override
public Result getAlertGroupList(Integer clusterId, String alertGroupName, 
                                Integer page, Integer pageSize) {
    // 构建分页对象
    Page<AlertGroupEntity> pageInfo = new Page<>(page, pageSize);
    
    // 构建查询条件
    LambdaQueryWrapper<AlertGroupEntity> queryWrapper = 
        new LambdaQueryWrapper<>();
    
    // 集群ID过滤
    if (clusterId != null) {
        queryWrapper.eq(AlertGroupEntity::getClusterId, clusterId);
    }
    
    // 名称模糊查询
    if (StringUtils.isNotBlank(alertGroupName)) {
        queryWrapper.like(AlertGroupEntity::getAlertGroupName, alertGroupName);
    }
    
    // 按创建时间倒序
    queryWrapper.orderByDesc(AlertGroupEntity::getCreateTime);
    
    // 执行分页查询
    Page<AlertGroupEntity> result = this.page(pageInfo, queryWrapper);
    
    // 填充额外信息
    result.getRecords().forEach(this::fillAlertGroupInfo);
    
    return Result.success().put("page", result);
}

/**
 * 填充告警组附加信息
 */
private void fillAlertGroupInfo(AlertGroupEntity alertGroup) {
    // 填充通知用户名称
    if (StringUtils.isNotBlank(alertGroup.getNoticeUserIds())) {
        String[] userIds = alertGroup.getNoticeUserIds().split(",");
        List<String> userNames = userInfoService.getUserNamesByIds(userIds);
        alertGroup.setNoticeUserNames(String.join(",", userNames));
    }
    
    // 统计关联的告警指标数量
    Long quotaCount = clusterAlertQuotaService.lambdaQuery()
        .eq(ClusterAlertQuota::getAlertGroupId, alertGroup.getId())
        .count();
    alertGroup.setAlertQuotaCount(quotaCount);
}
```

**功能特点**:
1. 支持集群ID过滤
2. 支持名称模糊搜索
3. 分页返回结果
4. 填充通知用户名称
5. 统计关联的告警指标数量

**性能优化**:
- 使用 MyBatis-Plus 的 LambdaQueryWrapper，类型安全
- 按需填充额外信息，避免 N+1 查询
- 可选的 Redis 缓存支持

#### 2.2.3 保存告警组

```java
@Override
@Transactional(rollbackFor = Exception.class)
public Result saveAlertGroup(AlertGroupEntity alertGroup) {
    // 1. 参数验证
    Result validationResult = validateAlertGroup(alertGroup);
    if (!validationResult.isSuccess()) {
        return validationResult;
    }
    
    // 2. 检查告警组名称是否重复
    Long count = this.lambdaQuery()
        .eq(AlertGroupEntity::getAlertGroupName, alertGroup.getAlertGroupName())
        .eq(AlertGroupEntity::getClusterId, alertGroup.getClusterId())
        .count();
    if (count > 0) {
        return Result.error("告警组名称已存在");
    }
    
    // 3. 设置默认值
    alertGroup.setCreateTime(new Date());
    alertGroup.setUpdateTime(new Date());
    
    // 4. 保存到数据库
    boolean saved = this.save(alertGroup);
    if (!saved) {
        return Result.error("保存告警组失败");
    }
    
    // 5. 创建集群告警组映射关系
    ClusterAlertGroupMap mapping = new ClusterAlertGroupMap();
    mapping.setClusterId(alertGroup.getClusterId());
    mapping.setAlertGroupId(alertGroup.getId());
    clusterAlertGroupMapMapper.insert(mapping);
    
    // 6. 清除缓存
    clearAlertGroupCache(alertGroup.getClusterId());
    
    // 7. 记录操作日志
    logOperation("CREATE", alertGroup);
    
    return Result.success().put("alertGroupId", alertGroup.getId());
}

/**
 * 验证告警组参数
 */
private Result validateAlertGroup(AlertGroupEntity alertGroup) {
    // 告警组名称不能为空
    if (StringUtils.isBlank(alertGroup.getAlertGroupName())) {
        return Result.error("告警组名称不能为空");
    }
    
    // 集群ID不能为空
    if (alertGroup.getClusterId() == null) {
        return Result.error("集群ID不能为空");
    }
    
    // 至少配置一种通知方式
    if (StringUtils.isBlank(alertGroup.getNoticeWay())) {
        return Result.error("至少配置一种通知方式");
    }
    
    // 至少指定一个通知人员
    if (StringUtils.isBlank(alertGroup.getNoticeUserIds()) 
        && StringUtils.isBlank(alertGroup.getNoticeGroupUserIds())) {
        return Result.error("至少指定一个通知人员或用户组");
    }
    
    // 验证通知配置
    return validateNotificationConfig(alertGroup);
}

/**
 * 验证通知配置
 */
private Result validateNotificationConfig(AlertGroupEntity alertGroup) {
    String[] noticeWays = alertGroup.getNoticeWay().split(",");
    
    for (String noticeWay : noticeWays) {
        switch (noticeWay.trim()) {
            case "EMAIL":
                if (StringUtils.isBlank(alertGroup.getEmailConfig())) {
                    return Result.error("邮件通知方式需要配置邮件参数");
                }
                // 验证邮件配置格式
                if (!isValidEmailConfig(alertGroup.getEmailConfig())) {
                    return Result.error("邮件配置格式不正确");
                }
                break;
            case "DINGDING":
                if (StringUtils.isBlank(alertGroup.getDingdingConfig())) {
                    return Result.error("钉钉通知方式需要配置钉钉参数");
                }
                break;
            case "WECHAT":
                if (StringUtils.isBlank(alertGroup.getWechatConfig())) {
                    return Result.error("企业微信通知方式需要配置企业微信参数");
                }
                break;
            case "WEBHOOK":
                if (StringUtils.isBlank(alertGroup.getWebhookConfig())) {
                    return Result.error("Webhook通知方式需要配置Webhook参数");
                }
                break;
        }
    }
    
    return Result.success();
}
```

**业务流程**:
1. **参数验证**: 检查必填字段和配置有效性
2. **唯一性检查**: 防止同一集群下告警组名称重复
3. **默认值设置**: 创建时间、更新时间
4. **数据保存**: 事务保证数据一致性
5. **映射关系**: 创建集群与告警组的映射
6. **缓存清除**: 保证数据实时性
7. **日志记录**: 审计追踪

**事务管理**:
- 使用 `@Transactional` 确保原子性
- 任何步骤失败都会回滚
- 保证数据一致性

#### 2.2.4 更新告警组

```java
@Override
@Transactional(rollbackFor = Exception.class)
public Result updateAlertGroup(AlertGroupEntity alertGroup) {
    // 1. 检查告警组是否存在
    AlertGroupEntity existing = this.getById(alertGroup.getId());
    if (existing == null) {
        return Result.error("告警组不存在");
    }
    
    // 2. 参数验证
    Result validationResult = validateAlertGroup(alertGroup);
    if (!validationResult.isSuccess()) {
        return validationResult;
    }
    
    // 3. 检查名称是否与其他告警组重复
    Long count = this.lambdaQuery()
        .eq(AlertGroupEntity::getAlertGroupName, alertGroup.getAlertGroupName())
        .eq(AlertGroupEntity::getClusterId, alertGroup.getClusterId())
        .ne(AlertGroupEntity::getId, alertGroup.getId())
        .count();
    if (count > 0) {
        return Result.error("告警组名称已存在");
    }
    
    // 4. 更新时间
    alertGroup.setUpdateTime(new Date());
    
    // 5. 更新数据库
    boolean updated = this.updateById(alertGroup);
    if (!updated) {
        return Result.error("更新告警组失败");
    }
    
    // 6. 清除缓存
    clearAlertGroupCache(alertGroup.getClusterId());
    
    // 7. 记录操作日志
    logOperation("UPDATE", alertGroup);
    
    // 8. 如果告警规则有变化，触发告警规则重载
    reloadAlertRules(alertGroup.getId());
    
    return Result.success();
}

/**
 * 重载告警规则
 */
private void reloadAlertRules(Integer alertGroupId) {
    // 获取该告警组关联的所有告警指标
    List<ClusterAlertQuota> quotas = clusterAlertQuotaService.lambdaQuery()
        .eq(ClusterAlertQuota::getAlertGroupId, alertGroupId)
        .list();
    
    // 通知 Prometheus 或其他监控系统重载规则
    for (ClusterAlertQuota quota : quotas) {
        // 发送重载命令给监控系统
        // 例如：prometheusService.reloadAlertRule(quota);
    }
}
```

**更新特性**:
1. 存在性检查
2. 名称唯一性验证（排除自身）
3. 自动更新时间戳
4. 缓存失效处理
5. 告警规则重载（如果配置变更影响规则）

#### 2.2.5 删除告警组

```java
@Override
@Transactional(rollbackFor = Exception.class)
public Result deleteAlertGroup(Integer[] ids) {
    // 1. 检查是否有关联的告警指标
    List<ClusterAlertQuota> quotas = clusterAlertQuotaService.lambdaQuery()
        .in(ClusterAlertQuota::getAlertGroupId, Arrays.asList(ids))
        .list();
    
    if (!quotas.isEmpty()) {
        // 返回详细的关联信息
        List<String> quotaNames = quotas.stream()
            .map(ClusterAlertQuota::getQuotaName)
            .collect(Collectors.toList());
        return Result.error("该告警组已绑定以下告警指标，无法删除：" 
            + String.join(", ", quotaNames));
    }
    
    // 2. 删除集群告警组映射关系
    clusterAlertGroupMapMapper.delete(
        new LambdaQueryWrapper<ClusterAlertGroupMap>()
            .in(ClusterAlertGroupMap::getAlertGroupId, Arrays.asList(ids))
    );
    
    // 3. 删除告警组
    boolean deleted = this.removeByIds(Arrays.asList(ids));
    if (!deleted) {
        return Result.error("删除告警组失败");
    }
    
    // 4. 清除相关缓存
    for (Integer id : ids) {
        AlertGroupEntity alertGroup = this.getById(id);
        if (alertGroup != null) {
            clearAlertGroupCache(alertGroup.getClusterId());
        }
    }
    
    // 5. 记录操作日志
    logOperation("DELETE", "批量删除告警组: " + Arrays.toString(ids));
    
    return Result.success();
}
```

**删除保护机制**:
1. **关联检查**: 检查是否有告警指标绑定
2. **级联删除**: 删除映射关系
3. **缓存清理**: 保证数据一致性
4. **审计日志**: 记录删除操作
5. **友好提示**: 告知用户哪些指标阻止了删除

#### 2.2.6 缓存管理

```java
/**
 * 清除告警组缓存
 */
private void clearAlertGroupCache(Integer clusterId) {
    if (redisTemplate != null) {
        // 清除集群维度的缓存
        String cacheKey = "alert:group:cluster:" + clusterId;
        redisTemplate.delete(cacheKey);
        
        // 清除告警组列表缓存
        String listCacheKey = "alert:group:list:" + clusterId;
        redisTemplate.delete(listCacheKey);
    }
}

/**
 * 从缓存获取告警组
 */
@Cacheable(value = "alert:group", key = "#id")
public AlertGroupEntity getAlertGroupById(Integer id) {
    return this.getById(id);
}

/**
 * 获取集群的所有告警组（带缓存）
 */
@Cacheable(value = "alert:group:cluster", key = "#clusterId")
public List<AlertGroupEntity> getAlertGroupsByClusterId(Integer clusterId) {
    return this.lambdaQuery()
        .eq(AlertGroupEntity::getClusterId, clusterId)
        .orderByDesc(AlertGroupEntity::getCreateTime)
        .list();
}
```

**缓存策略**:
- **单个告警组**: 按 ID 缓存，提升详情查询性能
- **集群告警组列表**: 按集群 ID 缓存
- **自动失效**: 增删改操作自动清除相关缓存
- **可选依赖**: Redis 不可用时自动降级

#### 2.2.7 操作日志记录

```java
/**
 * 记录操作日志
 */
private void logOperation(String operation, Object data) {
    try {
        String username = SecurityUtils.getCurrentUser();
        String logMessage = String.format(
            "用户 %s 执行告警组操作: %s, 数据: %s",
            username, operation, JSON.toJSONString(data)
        );
        logger.info(logMessage);
        
        // 可选：保存到操作日志表
        // operationLogService.save(operation, "AlertGroup", logMessage);
    } catch (Exception e) {
        logger.error("记录操作日志失败", e);
    }
}
```

## 三、ClusterAlertQuotaService - 告警指标服务

### 3.1 服务职责

告警指标服务负责管理监控指标的阈值配置、指标与告警组的关联关系。

**文件位置**: `datasophon-service/src/main/java/com/datasophon/api/service/ClusterAlertQuotaService.java`

### 3.2 核心接口

```java
public interface ClusterAlertQuotaService extends IService<ClusterAlertQuota> {
    
    /**
     * 获取告警指标列表
     * @param clusterId 集群ID
     * @param alertGroupId 告警组ID
     * @param page 页码
     * @param pageSize 每页大小
     * @return 分页结果
     */
    Result getAlertQuotaList(Integer clusterId, Integer alertGroupId,
                            Integer page, Integer pageSize);
    
    /**
     * 保存告警指标
     * @param quota 告警指标实体
     * @return 操作结果
     */
    Result saveAlertQuota(ClusterAlertQuota quota);
    
    /**
     * 更新告警指标
     * @param quota 告警指标实体
     * @return 操作结果
     */
    Result updateAlertQuota(ClusterAlertQuota quota);
    
    /**
     * 删除告警指标
     * @param ids 指标ID数组
     * @return 操作结果
     */
    Result deleteAlertQuota(Integer[] ids);
    
    /**
     * 获取告警组的所有指标
     * @param alertGroupId 告警组ID
     * @return 指标列表
     */
    List<ClusterAlertQuota> getQuotasByAlertGroupId(Integer alertGroupId);
    
    /**
     * 批量更新指标的告警组
     * @param quotaIds 指标ID列表
     * @param alertGroupId 新的告警组ID
     * @return 操作结果
     */
    Result updateQuotasAlertGroup(List<Integer> quotaIds, Integer alertGroupId);
}
```

### 3.3 告警指标实体

```java
public class ClusterAlertQuota {
    private Integer id;                    // 主键ID
    private Integer clusterId;             // 集群ID
    private String quotaName;              // 指标名称
    private String serviceName;            // 服务名称（如 HDFS、YARN）
    private String serviceRoleName;        // 服务角色名称（如 NameNode）
    private Integer alertGroupId;          // 告警组ID
    private String alertLevel;             // 告警级别
    private String alertExpr;              // 告警表达式（Prometheus QL）
    private Integer alertDuration;         // 持续时间（秒）
    private String alertAdvice;            // 告警建议
    private Integer triggerThreshold;      // 触发阈值
    private String compareMethod;          // 比较方法（>、<、==、!=）
    private Integer enabled;               // 是否启用（0-禁用，1-启用）
    private Date createTime;               // 创建时间
    private Date updateTime;               // 更新时间
}
```

### 3.4 关键实现

```java
@Service
public class ClusterAlertQuotaServiceImpl 
    extends ServiceImpl<ClusterAlertQuotaMapper, ClusterAlertQuota>
    implements ClusterAlertQuotaService {
    
    @Autowired
    private AlertGroupService alertGroupService;
    
    @Autowired
    private PrometheusService prometheusService;
    
    /**
     * 保存告警指标
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Result saveAlertQuota(ClusterAlertQuota quota) {
        // 1. 验证告警组是否存在
        AlertGroupEntity alertGroup = 
            alertGroupService.getById(quota.getAlertGroupId());
        if (alertGroup == null) {
            return Result.error("告警组不存在");
        }
        
        // 2. 验证告警表达式
        if (!isValidAlertExpr(quota.getAlertExpr())) {
            return Result.error("告警表达式格式不正确");
        }
        
        // 3. 设置默认值
        quota.setCreateTime(new Date());
        quota.setUpdateTime(new Date());
        if (quota.getEnabled() == null) {
            quota.setEnabled(1); // 默认启用
        }
        
        // 4. 保存到数据库
        boolean saved = this.save(quota);
        if (!saved) {
            return Result.error("保存告警指标失败");
        }
        
        // 5. 同步到 Prometheus
        syncToPrometheus(quota);
        
        return Result.success().put("quotaId", quota.getId());
    }
    
    /**
     * 验证告警表达式
     */
    private boolean isValidAlertExpr(String alertExpr) {
        // 简单的 Prometheus QL 语法检查
        // 实际应该调用 Prometheus API 进行验证
        return StringUtils.isNotBlank(alertExpr) 
            && !alertExpr.contains("';") 
            && !alertExpr.contains("--");
    }
    
    /**
     * 同步告警规则到 Prometheus
     */
    private void syncToPrometheus(ClusterAlertQuota quota) {
        try {
            // 构建 Prometheus 告警规则
            PrometheusAlertRule rule = PrometheusAlertRule.builder()
                .alert(quota.getQuotaName())
                .expr(quota.getAlertExpr())
                .duration(quota.getAlertDuration() + "s")
                .labels(buildLabels(quota))
                .annotations(buildAnnotations(quota))
                .build();
            
            // 推送到 Prometheus
            prometheusService.createOrUpdateAlertRule(rule);
        } catch (Exception e) {
            logger.error("同步告警规则到 Prometheus 失败", e);
        }
    }
    
    /**
     * 构建告警标签
     */
    private Map<String, String> buildLabels(ClusterAlertQuota quota) {
        Map<String, String> labels = new HashMap<>();
        labels.put("severity", quota.getAlertLevel().toLowerCase());
        labels.put("cluster_id", String.valueOf(quota.getClusterId()));
        labels.put("service", quota.getServiceName());
        if (StringUtils.isNotBlank(quota.getServiceRoleName())) {
            labels.put("role", quota.getServiceRoleName());
        }
        return labels;
    }
    
    /**
     * 构建告警注解
     */
    private Map<String, String> buildAnnotations(ClusterAlertQuota quota) {
        Map<String, String> annotations = new HashMap<>();
        annotations.put("summary", quota.getQuotaName());
        annotations.put("description", quota.getAlertExpr());
        if (StringUtils.isNotBlank(quota.getAlertAdvice())) {
            annotations.put("advice", quota.getAlertAdvice());
        }
        return annotations;
    }
    
    /**
     * 批量更新指标的告警组
     */
    @Override
    @Transactional(rollbackFor = Exception.class)
    public Result updateQuotasAlertGroup(List<Integer> quotaIds, 
                                        Integer alertGroupId) {
        // 验证告警组存在
        AlertGroupEntity alertGroup = 
            alertGroupService.getById(alertGroupId);
        if (alertGroup == null) {
            return Result.error("告警组不存在");
        }
        
        // 批量更新
        boolean updated = this.lambdaUpdate()
            .set(ClusterAlertQuota::getAlertGroupId, alertGroupId)
            .set(ClusterAlertQuota::getUpdateTime, new Date())
            .in(ClusterAlertQuota::getId, quotaIds)
            .update();
        
        if (!updated) {
            return Result.error("更新失败");
        }
        
        // 重新同步到 Prometheus
        for (Integer quotaId : quotaIds) {
            ClusterAlertQuota quota = this.getById(quotaId);
            syncToPrometheus(quota);
        }
        
        return Result.success();
    }
}
```

**核心功能**:
1. **指标管理**: CRUD 操作
2. **表达式验证**: 防止 SQL 注入和语法错误
3. **Prometheus 集成**: 自动同步告警规则
4. **批量操作**: 支持批量修改告警组

## 四、ClusterAlertRuleService - 告警规则服务

### 4.1 服务概述

告警规则服务管理告警的触发规则、通知策略和规则模板。

**文件位置**: `datasophon-service/src/main/java/com/datasophon/api/service/ClusterAlertRuleService.java`

### 4.2 规则实体

```java
public class ClusterAlertRule {
    private Integer id;                    // 主键ID
    private Integer clusterId;             // 集群ID
    private String ruleName;               // 规则名称
    private String ruleType;               // 规则类型（THRESHOLD、TREND、ANOMALY）
    private Integer alertGroupId;          // 告警组ID
    private String triggerCondition;       // 触发条件
    private Integer silencePeriod;         // 静默期（秒）
    private Integer maxAlertCount;         // 最大告警次数（防止告警风暴）
    private String enabled;                // 是否启用
    private Date createTime;               // 创建时间
    private Date updateTime;               // 更新时间
}
```

### 4.3 规则类型

```java
public enum AlertRuleType {
    /**
     * 阈值告警：指标超过阈值触发
     */
    THRESHOLD("THRESHOLD", "阈值告警"),
    
    /**
     * 趋势告警：指标变化趋势异常
     */
    TREND("TREND", "趋势告警"),
    
    /**
     * 异常检测：基于机器学习的异常检测
     */
    ANOMALY("ANOMALY", "异常检测"),
    
    /**
     * 复合告警：多个条件组合
     */
    COMPOSITE("COMPOSITE", "复合告警");
}
```

### 4.4 核心实现

```java
@Service
public class ClusterAlertRuleServiceImpl 
    extends ServiceImpl<ClusterAlertRuleMapper, ClusterAlertRule>
    implements ClusterAlertRuleService {
    
    /**
     * 评估告警规则
     */
    public boolean evaluateRule(ClusterAlertRule rule, 
                               Map<String, Object> metrics) {
        switch (rule.getRuleType()) {
            case "THRESHOLD":
                return evaluateThresholdRule(rule, metrics);
            case "TREND":
                return evaluateTrendRule(rule, metrics);
            case "ANOMALY":
                return evaluateAnomalyRule(rule, metrics);
            case "COMPOSITE":
                return evaluateCompositeRule(rule, metrics);
            default:
                return false;
        }
    }
    
    /**
     * 评估阈值规则
     */
    private boolean evaluateThresholdRule(ClusterAlertRule rule,
                                         Map<String, Object> metrics) {
        // 解析触发条件
        // 例如: "cpu_usage > 80"
        String condition = rule.getTriggerCondition();
        // ... 实现条件评估逻辑
        return false;
    }
    
    /**
     * 检查是否在静默期
     */
    public boolean isInSilencePeriod(Integer ruleId) {
        String cacheKey = "alert:silence:" + ruleId;
        return redisTemplate.hasKey(cacheKey);
    }
    
    /**
     * 设置静默期
     */
    public void setSilencePeriod(Integer ruleId, Integer seconds) {
        String cacheKey = "alert:silence:" + ruleId;
        redisTemplate.opsForValue().set(cacheKey, "1", 
            seconds, TimeUnit.SECONDS);
    }
}
```

## 五、ClusterAlertHistoryService - 告警历史服务

### 5.1 服务概述

告警历史服务记录和查询所有告警事件，提供告警统计和趋势分析。

**文件位置**: `datasophon-service/src/main/java/com/datasophon/api/service/ClusterAlertHistoryService.java`

### 5.2 历史实体

```java
public class ClusterAlertHistory {
    private Long id;                       // 主键ID（使用 Long 支持海量数据）
    private Integer clusterId;             // 集群ID
    private Integer alertGroupId;          // 告警组ID
    private Integer alertQuotaId;          // 告警指标ID
    private String alertLevel;             // 告警级别
    private String alertInfo;              // 告警信息
    private String alertAdvice;            // 处理建议
    private String hostname;               // 主机名
    private String serviceName;            // 服务名称
    private String serviceRoleName;        // 服务角色名称
    private Integer alertStatus;           // 告警状态（0-触发，1-恢复）
    private Date alertTime;                // 告警时间
    private Date resolveTime;              // 恢复时间
    private String noticeStatus;           // 通知状态（SUCCESS、FAILED）
    private Integer noticeRetryCount;      // 通知重试次数
}
```

### 5.3 核心接口

```java
public interface ClusterAlertHistoryService 
    extends IService<ClusterAlertHistory> {
    
    /**
     * 记录告警历史
     */
    void recordAlertHistory(ClusterAlertHistory history);
    
    /**
     * 获取告警历史列表
     */
    Result getAlertHistoryList(AlertHistoryQuery query);
    
    /**
     * 获取告警统计
     */
    Result getAlertStatistics(Integer clusterId, Date startTime, Date endTime);
    
    /**
     * 获取告警趋势
     */
    Result getAlertTrend(Integer clusterId, String timeRange);
    
    /**
     * 标记告警已恢复
     */
    Result markAlertResolved(Long alertId);
}
```

### 5.4 实现示例

```java
@Service
public class ClusterAlertHistoryServiceImpl 
    extends ServiceImpl<ClusterAlertHistoryMapper, ClusterAlertHistory>
    implements ClusterAlertHistoryService {
    
    /**
     * 记录告警历史
     */
    @Override
    @Async("alertExecutor")
    public void recordAlertHistory(ClusterAlertHistory history) {
        try {
            history.setAlertTime(new Date());
            this.save(history);
            
            // 发送告警通知
            sendAlertNotification(history);
        } catch (Exception e) {
            logger.error("记录告警历史失败", e);
        }
    }
    
    /**
     * 获取告警统计
     */
    @Override
    public Result getAlertStatistics(Integer clusterId, 
                                    Date startTime, Date endTime) {
        // 按级别统计
        Map<String, Long> levelStats = this.lambdaQuery()
            .eq(ClusterAlertHistory::getClusterId, clusterId)
            .between(ClusterAlertHistory::getAlertTime, startTime, endTime)
            .groupBy(ClusterAlertHistory::getAlertLevel)
            .list()
            .stream()
            .collect(Collectors.groupingBy(
                ClusterAlertHistory::getAlertLevel,
                Collectors.counting()
            ));
        
        // 按服务统计
        Map<String, Long> serviceStats = this.lambdaQuery()
            .eq(ClusterAlertHistory::getClusterId, clusterId)
            .between(ClusterAlertHistory::getAlertTime, startTime, endTime)
            .groupBy(ClusterAlertHistory::getServiceName)
            .list()
            .stream()
            .collect(Collectors.groupingBy(
                ClusterAlertHistory::getServiceName,
                Collectors.counting()
            ));
        
        Map<String, Object> statistics = new HashMap<>();
        statistics.put("levelStats", levelStats);
        statistics.put("serviceStats", serviceStats);
        statistics.put("totalCount", levelStats.values().stream()
            .mapToLong(Long::longValue).sum());
        
        return Result.success().put("statistics", statistics);
    }
    
    /**
     * 发送告警通知
     */
    private void sendAlertNotification(ClusterAlertHistory history) {
        // 获取告警组配置
        AlertGroupEntity alertGroup = 
            alertGroupService.getById(history.getAlertGroupId());
        if (alertGroup == null) {
            return;
        }
        
        // 构建告警消息
        AlertMessage message = buildAlertMessage(history, alertGroup);
        
        // 根据配置的通知方式发送
        String[] noticeWays = alertGroup.getNoticeWay().split(",");
        for (String noticeWay : noticeWays) {
            try {
                sendByNoticeWay(noticeWay.trim(), message, alertGroup);
                updateNoticeStatus(history.getId(), "SUCCESS");
            } catch (Exception e) {
                logger.error("发送告警通知失败: " + noticeWay, e);
                updateNoticeStatus(history.getId(), "FAILED");
            }
        }
    }
}
```

## 六、服务集成与协作

### 6.1 服务调用关系

```
Controller 层
    └──> AlertGroupService
            ├──> ClusterAlertQuotaService (检查删除约束)
            ├──> ClusterAlertRuleService (规则管理)
            ├──> ClusterAlertHistoryService (历史记录)
            ├──> UserInfoService (用户信息)
            └──> PrometheusService (监控集成)
```

### 6.2 事件驱动架构

```java
/**
 * 告警事件发布器
 */
@Component
public class AlertEventPublisher {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    /**
     * 发布告警触发事件
     */
    public void publishAlertTriggered(ClusterAlertHistory alert) {
        AlertTriggeredEvent event = new AlertTriggeredEvent(this, alert);
        eventPublisher.publishEvent(event);
    }
    
    /**
     * 发布告警恢复事件
     */
    public void publishAlertResolved(ClusterAlertHistory alert) {
        AlertResolvedEvent event = new AlertResolvedEvent(this, alert);
        eventPublisher.publishEvent(event);
    }
}

/**
 * 告警事件监听器
 */
@Component
public class AlertEventListener {
    
    @Autowired
    private ClusterAlertHistoryService alertHistoryService;
    
    /**
     * 监听告警触发事件
     */
    @EventListener
    @Async("alertExecutor")
    public void handleAlertTriggered(AlertTriggeredEvent event) {
        ClusterAlertHistory alert = event.getAlert();
        
        // 记录告警历史
        alertHistoryService.recordAlertHistory(alert);
        
        // 发送通知
        // ...
    }
    
    /**
     * 监听告警恢复事件
     */
    @EventListener
    @Async("alertExecutor")
    public void handleAlertResolved(AlertResolvedEvent event) {
        ClusterAlertHistory alert = event.getAlert();
        
        // 更新告警状态
        alertHistoryService.markAlertResolved(alert.getId());
        
        // 发送恢复通知
        // ...
    }
}
```

### 6.3 异步处理

```java
/**
 * 告警异步配置
 */
@Configuration
@EnableAsync
public class AlertAsyncConfig {
    
    @Bean("alertExecutor")
    public Executor alertExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("alert-");
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        executor.initialize();
        return executor;
    }
}
```

## 七、性能优化与最佳实践

### 7.1 批量通知优化

```java
/**
 * 批量发送告警通知
 */
public void batchNotify(List<ClusterAlertHistory> alerts) {
    // 按告警组分组
    Map<Integer, List<ClusterAlertHistory>> groupedAlerts = alerts.stream()
        .collect(Collectors.groupingBy(
            ClusterAlertHistory::getAlertGroupId
        ));
    
    // 并发发送
    List<CompletableFuture<Void>> futures = new ArrayList<>();
    groupedAlerts.forEach((alertGroupId, groupAlerts) -> {
        CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
            notifyAlertGroup(alertGroupId, groupAlerts);
        }, alertExecutor);
        futures.add(future);
    });
    
    // 等待所有通知完成
    CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
        .join();
}
```

### 7.2 告警防抖动

```java
/**
 * 告警防抖动
 */
public boolean shouldTriggerAlert(ClusterAlertHistory alert) {
    String cacheKey = String.format("alert:debounce:%d:%d",
        alert.getClusterId(), alert.getAlertQuotaId());
    
    // 检查最近是否已触发
    Long lastTriggerTime = (Long) redisTemplate.opsForValue().get(cacheKey);
    if (lastTriggerTime != null) {
        long elapsed = System.currentTimeMillis() - lastTriggerTime;
        if (elapsed < DEBOUNCE_PERIOD) {
            return false; // 防抖动期内，不触发
        }
    }
    
    // 记录触发时间
    redisTemplate.opsForValue().set(cacheKey, 
        System.currentTimeMillis(), 
        DEBOUNCE_PERIOD, TimeUnit.MILLISECONDS);
    
    return true;
}
```

### 7.3 告警聚合

```java
/**
 * 告警聚合
 */
public List<AggregatedAlert> aggregateAlerts(List<ClusterAlertHistory> alerts) {
    // 按服务和级别聚合
    Map<String, List<ClusterAlertHistory>> aggregated = alerts.stream()
        .collect(Collectors.groupingBy(alert -> 
            alert.getServiceName() + ":" + alert.getAlertLevel()
        ));
    
    List<AggregatedAlert> result = new ArrayList<>();
    aggregated.forEach((key, groupAlerts) -> {
        AggregatedAlert agg = new AggregatedAlert();
        agg.setServiceName(groupAlerts.get(0).getServiceName());
        agg.setAlertLevel(groupAlerts.get(0).getAlertLevel());
        agg.setCount(groupAlerts.size());
        agg.setAlerts(groupAlerts);
        result.add(agg);
    });
    
    return result;
}
```

## 八、总结

### 8.1 服务层架构优势

1. **清晰的职责划分**: 每个服务类专注于特定的业务领域
2. **良好的可测试性**: 接口与实现分离，便于单元测试
3. **高内聚低耦合**: 服务间通过接口交互，减少依赖
4. **事务管理**: 确保数据一致性
5. **异步处理**: 提升系统响应速度

### 8.2 核心服务总结

| 服务类 | 主要职责 | 核心功能 |
|--------|----------|----------|
| AlertGroupService | 告警组管理 | CRUD、缓存、验证 |
| ClusterAlertQuotaService | 告警指标管理 | 指标配置、Prometheus 集成 |
| ClusterAlertRuleService | 告警规则管理 | 规则评估、静默期管理 |
| ClusterAlertHistoryService | 告警历史管理 | 历史记录、统计分析 |

### 8.3 技术特点

- **MyBatis-Plus 集成**: 简化 CRUD 操作
- **Spring 事务管理**: 保证数据一致性
- **缓存机制**: 提升查询性能
- **异步处理**: 提高响应速度
- **事件驱动**: 解耦业务逻辑
- **Prometheus 集成**: 实时监控告警

### 8.4 最佳实践建议

1. **参数验证**: 在服务层进行完整的参数校验
2. **事务管理**: 合理使用 @Transactional 注解
3. **异常处理**: 统一的异常处理机制
4. **日志记录**: 详细的操作日志
5. **缓存策略**: 合理使用缓存提升性能
6. **批量操作**: 减少数据库交互次数
7. **异步处理**: 耗时操作异步执行

---

**文档版本**: v1.0  
**最后更新**: 2025-11-16  
**维护者**: DataSophon 源码分析团队  
**关联文档**: 
- [API 层 - 06-告警管理Controller.md](../api/06-告警管理Controller.md)
- [Service 层 - 00-Service模块总览.md](./00-Service模块总览.md)
