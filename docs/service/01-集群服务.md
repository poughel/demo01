# ClusterInfoService 集群服务详解

## 一、模块概述

### 1.1 基本信息

**文件位置**:
- 接口: `datasophon-service/src/main/java/com/datasophon/api/service/ClusterInfoService.java`
- 实现: `datasophon-service/src/main/java/com/datasophon/api/service/impl/ClusterInfoServiceImpl.java`

**职责定位**:
ClusterInfoService 是 DataSophon 平台的核心服务之一，负责管理大数据集群的全生命周期，包括集群的创建、查询、更新、删除以及状态管理。它是集群管理功能的核心业务逻辑层。

**核心概念**:
- **集群 (Cluster)**: DataSophon 管理的大数据集群实例
- **集群状态**: 包括需要配置、运行中、已停止、删除中等多种状态
- **集群框架**: 支持的大数据框架类型，如 Hadoop、Kafka 等
- **集群编码**: 集群的唯一标识符

### 1.2 类结构

```java
@Slf4j
@Service("clusterInfoService")
@Transactional
public class ClusterInfoServiceImpl extends ServiceImpl<ClusterInfoMapper, ClusterInfoEntity>
        implements ClusterInfoService
```

**继承关系**:
- 继承 `ServiceImpl<ClusterInfoMapper, ClusterInfoEntity>` (MyBatis-Plus 基础服务类)
- 实现 `ClusterInfoService` 接口

**依赖关系**:
该服务依赖多个其他服务协同工作：
- `ClusterInfoMapper`: 数据访问层
- `ClusterRoleUserService`: 集群用户管理
- `AlertGroupService`: 告警组管理
- `ClusterAlertGroupMapService`: 集群告警组映射
- `FrameServiceService`: 框架服务管理
- `ClusterHostService`: 主机管理
- `ClusterYarnSchedulerService`: YARN 调度器管理
- `ClusterNodeLabelService`: 节点标签管理
- `ClusterQueueCapacityService`: 队列容量管理
- `ClusterRackService`: 机架管理
- `ClusterServiceInstanceService`: 服务实例管理

## 二、核心功能详解

### 2.1 集群创建 (saveCluster)

**功能描述**:
创建新的集群实例，初始化集群的基础配置和默认资源。

**方法签名**:
```java
public Result saveCluster(ClusterInfoEntity clusterInfo)
```

**执行流程**:
1. **集群编码唯一性校验**: 检查集群编码是否已存在
2. **设置基础信息**: 创建时间、创建人、初始状态
3. **保存集群信息**: 持久化到数据库
4. **关联告警组**: 将所有已存在的告警组关联到新集群
5. **初始化 YARN 调度器**: 创建默认的 YARN 调度器配置
6. **初始化节点标签**: 创建默认的节点标签
7. **初始化队列容量**: 创建默认的队列配置
8. **初始化机架信息**: 创建默认的机架配置
9. **缓存全局变量**: 将集群相关的全局变量放入缓存

**代码实现**:
```java
@Override
public Result saveCluster(ClusterInfoEntity clusterInfo) {
    // 1. 校验集群编码唯一性
    List<ClusterInfoEntity> list = this
            .list(new QueryWrapper<ClusterInfoEntity>()
                .eq(Constants.CLUSTER_CODE, clusterInfo.getClusterCode()));
    if (Objects.nonNull(list) && !list.isEmpty()) {
        return Result.error(Status.CLUSTER_CODE_EXISTS.getMsg());
    }
    
    // 2. 设置基础信息
    clusterInfo.setCreateTime(new Date());
    clusterInfo.setCreateBy(SecurityUtils.getAuthUser().getUsername());
    clusterInfo.setClusterState(ClusterState.NEED_CONFIG);
    this.save(clusterInfo);
    
    // 3. 关联告警组
    List<AlertGroupEntity> alertGroupList = alertGroupService.list();
    for (AlertGroupEntity alertGroupEntity : alertGroupList) {
        ClusterAlertGroupMap alertGroupMap = new ClusterAlertGroupMap();
        alertGroupMap.setAlertGroupId(alertGroupEntity.getId());
        alertGroupMap.setClusterId(clusterInfo.getId());
        groupMapService.save(alertGroupMap);
    }
    
    // 4. 初始化默认配置
    yarnSchedulerService.createDefaultYarnScheduler(clusterInfo.getId());
    nodeLabelService.createDefaultNodeLabel(clusterInfo.getId());
    queueCapacityService.createDefaultQueue(clusterInfo.getId());
    rackService.createDefaultRack(clusterInfo.getId());
    
    // 5. 缓存全局变量
    putClusterVariable(clusterInfo);
    
    return Result.success();
}
```

**使用示例**:
```java
ClusterInfoEntity cluster = new ClusterInfoEntity();
cluster.setClusterName("生产集群");
cluster.setClusterCode("prod-cluster-001");
cluster.setClusterFrame("DDP-1.2.0");
Result result = clusterInfoService.saveCluster(cluster);
```

### 2.2 集群查询 (getClusterList)

**功能描述**:
获取所有集群列表，包含集群管理员信息和状态编码。

**方法签名**:
```java
public Result getClusterList()
```

**执行流程**:
1. 查询所有集群信息
2. 为每个集群附加管理员列表
3. 设置集群状态编码
4. 返回完整的集群列表

**代码实现**:
```java
@Override
public Result getClusterList() {
    List<ClusterInfoEntity> list = this.list();
    for (ClusterInfoEntity clusterInfoEntity : list) {
        // 获取集群管理员列表
        List<UserInfoEntity> userList =
                clusterUserService.getAllClusterManagerByClusterId(clusterInfoEntity.getId());
        clusterInfoEntity.setClusterManagerList(userList);
        
        // 设置状态编码
        clusterInfoEntity.setClusterStateCode(clusterInfoEntity.getClusterState().getValue());
    }
    return Result.success(list);
}
```

**返回数据示例**:
```json
{
  "code": 200,
  "msg": "success",
  "data": [
    {
      "id": 1,
      "clusterName": "生产集群",
      "clusterCode": "prod-cluster-001",
      "clusterFrame": "DDP-1.2.0",
      "clusterState": "RUNNING",
      "clusterStateCode": 1,
      "clusterManagerList": [
        {
          "id": 1,
          "username": "admin",
          "email": "admin@example.com"
        }
      ],
      "createTime": "2024-01-01 10:00:00"
    }
  ]
}
```

### 2.3 运行中集群查询 (runningClusterList)

**功能描述**:
获取所有处于运行状态的集群列表。

**方法签名**:
```java
public Result runningClusterList()
```

**代码实现**:
```java
@Override
public Result runningClusterList() {
    List<ClusterInfoEntity> list =
            this.list(new QueryWrapper<ClusterInfoEntity>()
                .eq(Constants.CLUSTER_STATE, ClusterState.RUNNING));
    return Result.success(list);
}
```

### 2.4 集群状态更新 (updateClusterState)

**功能描述**:
更新集群的运行状态。

**方法签名**:
```java
public Result updateClusterState(Integer clusterId, Integer clusterState)
```

**参数说明**:
- `clusterId`: 集群ID
- `clusterState`: 新的状态值

**支持的状态**:
- `NEED_CONFIG (0)`: 需要配置
- `RUNNING (1)`: 运行中
- `STOP (2)`: 已停止
- `DELETING (3)`: 删除中

**代码实现**:
```java
@Override
public Result updateClusterState(Integer clusterId, Integer clusterState) {
    ClusterInfoEntity clusterInfo = this.getById(clusterId);
    ClusterState state = ClusterState.of(clusterState);
    if (state != null) {
        clusterInfo.setClusterState(state);
        this.updateById(clusterInfo);
        return Result.success();
    } else {
        return Result.error("未知状态");
    }
}
```

### 2.5 集群更新 (updateCluster)

**功能描述**:
更新集群基本信息，支持集群编码变更时重建 Actor。

**方法签名**:
```java
public Result updateCluster(ClusterInfoEntity clusterInfo)
```

**执行流程**:
1. 校验新的集群编码是否与其他集群冲突
2. 检查集群编码是否变更
3. 如果编码变更，重建服务 Actor
4. 更新集群信息

**代码实现**:
```java
@Override
public Result updateCluster(ClusterInfoEntity clusterInfo) {
    // 1. 集群编码判重
    List<ClusterInfoEntity> list = this
            .list(new QueryWrapper<ClusterInfoEntity>()
                .eq(Constants.CLUSTER_CODE, clusterInfo.getClusterCode()));
    if (Objects.nonNull(list) && !list.isEmpty()) {
        ClusterInfoEntity clusterInfoEntity = list.get(0);
        if (!clusterInfoEntity.getId().equals(clusterInfo.getId())) {
            return Result.error(Status.CLUSTER_CODE_EXISTS.getMsg());
        }
    }
    
    // 2. 检查编码变更
    ClusterInfoEntity cluster = this.getById(clusterInfo.getId());
    if (!cluster.getClusterCode().equals(clusterInfo.getClusterCode())) {
        ProcessUtils.createServiceActor(clusterInfo);
    }
    
    // 3. 更新集群信息
    this.updateById(clusterInfo);
    return Result.success();
}
```

### 2.6 集群删除 (deleteCluster)

**功能描述**:
删除集群，根据集群状态采取不同的删除策略。

**方法签名**:
```java
public void deleteCluster(List<Integer> ids)
```

**删除策略**:

**策略一：已停止集群的删除**
- 条件：集群状态为 STOP 且无运行中的角色实例
- 操作：
  1. 发送删除命令到 ClusterActor
  2. 更新集群状态为 DELETING
  3. 异步执行实际删除操作

**策略二：未配置集群的删除**
- 条件：集群状态为 NEED_CONFIG
- 操作：
  1. 直接删除集群记录
  2. 删除关联的主机信息

**代码实现**:
```java
@Override
public void deleteCluster(List<Integer> ids) {
    Integer id = ids.get(0);
    ClusterInfoEntity clusterInfo = this.getById(id);
    
    // 策略一：已停止的集群
    if (ClusterState.STOP.equals(clusterInfo.getClusterState())) {
        List<ClusterServiceInstanceEntity> serviceInstanceList = 
            clusterServiceInstanceService.listAll(id);
        
        // 检查是否有运行中的实例
        if (serviceInstanceList.stream()
                .noneMatch(instance -> 
                    clusterServiceInstanceService.hasRunningRoleInstance(instance.getId()))) {
            // 发送删除命令
            ActorUtils.getLocalActor(ClusterActor.class, "clusterActor")
                    .tell(new ClusterCommand(ClusterCommandType.DELETE, id), 
                          ActorRef.noSender());
            
            // 更新状态为删除中
            this.updateClusterState(id, ClusterState.DELETING.getValue());
        }
    }
    
    // 策略二：未配置的集群
    if (ClusterState.NEED_CONFIG.equals(clusterInfo.getClusterState())) {
        this.removeByIds(ids);
        clusterHostService.removeHostByClusterId(id);
    }
}
```

**安全限制**:
- 运行中的集群不能直接删除
- 有运行中角色实例的集群不能删除
- 删除操作通过 Actor 异步执行，确保安全性

### 2.7 按框架代码查询 (getClusterByFrameCode)

**功能描述**:
根据框架代码查询使用该框架的所有集群。

**方法签名**:
```java
public List<ClusterInfoEntity> getClusterByFrameCode(String frameCode)
```

**使用场景**:
- 查询使用特定版本框架的集群
- 框架升级影响分析
- 框架兼容性检查

### 2.8 按集群编码查询 (getClusterByClusterCode)

**功能描述**:
根据集群编码获取集群信息。

**方法签名**:
```java
public ClusterInfoEntity getClusterByClusterCode(String clusterCode)
```

**使用场景**:
- 通过唯一标识快速定位集群
- 集群间调用和通信

## 三、数据模型

### 3.1 实体类 ClusterInfoEntity

**核心字段**:

| 字段名 | 类型 | 说明 | 示例 |
|--------|------|------|------|
| id | Integer | 集群ID（主键） | 1 |
| clusterName | String | 集群名称 | "生产集群" |
| clusterCode | String | 集群编码（唯一） | "prod-cluster-001" |
| clusterFrame | String | 集群框架版本 | "DDP-1.2.0" |
| clusterState | ClusterState | 集群状态枚举 | RUNNING |
| clusterStateCode | Integer | 状态编码 | 1 |
| createTime | Date | 创建时间 | "2024-01-01 10:00:00" |
| createBy | String | 创建人 | "admin" |
| frameId | Integer | 框架ID | 1 |

**关联对象**:
- `clusterManagerList`: 集群管理员列表（List<UserInfoEntity>）

### 3.2 枚举 ClusterState

```java
public enum ClusterState {
    NEED_CONFIG(0, "需要配置"),
    RUNNING(1, "运行中"),
    STOP(2, "已停止"),
    DELETING(3, "删除中");
    
    private final Integer value;
    private final String desc;
}
```

## 四、设计模式与架构

### 4.1 设计模式应用

**1. 服务层模式 (Service Layer Pattern)**
- 职责：封装业务逻辑，提供事务管理
- 优势：解耦业务逻辑和数据访问，便于测试和维护

**2. Actor 模型 (Actor Model)**
- 应用：集群删除使用 ClusterActor 异步处理
- 优势：高并发、容错、异步处理

**3. 策略模式 (Strategy Pattern)**
- 应用：根据集群状态采用不同的删除策略
- 优势：灵活处理不同场景，易于扩展

### 4.2 架构设计

**分层架构**:
```
Controller 层 (ClusterInfoController)
      ↓
Service 层 (ClusterInfoService)
      ↓
Mapper 层 (ClusterInfoMapper)
      ↓
Database (MySQL)
```

**依赖注入**:
使用 Spring 的依赖注入管理服务间依赖：
```java
@Autowired
private ClusterInfoMapper clusterInfoMapper;

@Autowired
private AlertGroupService alertGroupService;

@Autowired
private ClusterHostService clusterHostService;
```

**事务管理**:
类级别添加 `@Transactional` 注解，确保数据一致性：
```java
@Service("clusterInfoService")
@Transactional
public class ClusterInfoServiceImpl extends ServiceImpl<...>
```

## 五、全局变量管理

### 5.1 全局变量缓存 (putClusterVariable)

**功能描述**:
为集群缓存必要的全局变量，供配置文件生成和命令执行使用。

**缓存的变量类型**:

1. **服务 HOME 目录**:
   - `${HDFS_HOME}`: HDFS 安装目录
   - `${YARN_HOME}`: YARN 安装目录
   - `${KAFKA_HOME}`: Kafka 安装目录
   - 等等...

2. **系统路径**:
   - `${INSTALL_PATH}`: 软件安装根目录
   - `${HADOOP_HOME}`: Hadoop 安装目录

3. **API 服务信息**:
   - `${apiHost}`: API 服务器主机名
   - `${apiPort}`: API 服务器端口

**代码实现**:
```java
private void putClusterVariable(ClusterInfoEntity clusterInfo) {
    HashMap<String, String> globalVariables = new HashMap<>();
    
    // 1. 获取框架服务列表
    List<FrameServiceEntity> frameServiceList =
            frameServiceService.getAllFrameServiceByFrameCode(clusterInfo.getClusterFrame());
    
    // 2. 为每个服务设置 HOME 变量
    for (FrameServiceEntity frameServiceEntity : frameServiceList) {
        globalVariables.put("${" + frameServiceEntity.getServiceName() + "_HOME}",
                Constants.INSTALL_PATH + Constants.SLASH + 
                frameServiceEntity.getDecompressPackageName());
    }
    
    // 3. 设置系统变量
    globalVariables.put("${INSTALL_PATH}", Constants.INSTALL_PATH);
    globalVariables.put("${apiHost}", CacheUtils.getString("hostname"));
    globalVariables.put("${apiPort}", configBean.getServerPort());
    globalVariables.put("${HADOOP_HOME}", Constants.INSTALL_PATH + Constants.SLASH
            + PackageUtils.getServiceDcPackageName(clusterInfo.getClusterFrame(), "HDFS"));
    
    // 4. 放入全局缓存
    GlobalVariables.put(clusterInfo.getId(), globalVariables);
}
```

**使用场景**:
- 配置文件模板变量替换
- Shell 脚本变量注入
- 服务启动命令构建

## 六、性能优化

### 6.1 查询优化

**1. 使用 MyBatis-Plus 简化查询**:
```java
// 简洁的条件查询
List<ClusterInfoEntity> list = this.list(
    new QueryWrapper<ClusterInfoEntity>()
        .eq(Constants.CLUSTER_STATE, ClusterState.RUNNING)
);
```

**2. 避免 N+1 查询问题**:
在 `getClusterList` 方法中，虽然循环查询用户列表，但考虑到集群数量通常不多，这是可接受的。如果集群数量增加，可以优化为：
```java
// 批量查询用户
Map<Integer, List<UserInfoEntity>> userMap = 
    clusterUserService.getUserMapByClusterIds(clusterIds);
```

### 6.2 缓存策略

**1. 全局变量缓存**:
```java
GlobalVariables.put(clusterInfo.getId(), globalVariables);
```
- 避免重复计算
- 提高配置生成速度
- 减少数据库访问

**2. 主机名缓存**:
```java
CacheUtils.getString("hostname")
```
- 避免重复获取系统信息

### 6.3 事务优化

**事务边界控制**:
- 类级别使用 `@Transactional`
- 确保一组相关操作的原子性
- 减少事务持有时间

## 七、安全性考虑

### 7.1 权限控制

**创建人记录**:
```java
clusterInfo.setCreateBy(SecurityUtils.getAuthUser().getUsername());
```
- 记录操作审计信息
- 支持权限追溯

**集群管理员**:
- 每个集群可配置多个管理员
- 通过 `ClusterRoleUserService` 管理权限

### 7.2 数据验证

**1. 唯一性校验**:
```java
List<ClusterInfoEntity> list = this.list(
    new QueryWrapper<ClusterInfoEntity>()
        .eq(Constants.CLUSTER_CODE, clusterInfo.getClusterCode())
);
if (Objects.nonNull(list) && !list.isEmpty()) {
    return Result.error(Status.CLUSTER_CODE_EXISTS.getMsg());
}
```

**2. 状态校验**:
```java
ClusterState state = ClusterState.of(clusterState);
if (state != null) {
    // 处理
} else {
    return Result.error("未知状态");
}
```

**3. 删除前置检查**:
```java
// 检查是否有运行中的实例
if (serviceInstanceList.stream()
        .noneMatch(instance -> 
            clusterServiceInstanceService.hasRunningRoleInstance(instance.getId()))) {
    // 允许删除
}
```

## 八、使用示例

### 8.1 创建集群完整示例

```java
// 1. 构建集群信息
ClusterInfoEntity cluster = new ClusterInfoEntity();
cluster.setClusterName("生产环境集群");
cluster.setClusterCode("prod-hadoop-001");
cluster.setClusterFrame("DDP-1.2.0");
cluster.setFrameId(1);

// 2. 调用服务创建
Result result = clusterInfoService.saveCluster(cluster);

// 3. 检查结果
if (result.getCode() == 200) {
    System.out.println("集群创建成功，ID: " + cluster.getId());
} else {
    System.out.println("创建失败: " + result.getMsg());
}
```

### 8.2 查询和状态管理示例

```java
// 1. 查询所有集群
Result allClusters = clusterInfoService.getClusterList();

// 2. 查询运行中的集群
Result runningClusters = clusterInfoService.runningClusterList();

// 3. 更新集群状态
clusterInfoService.updateClusterState(clusterId, ClusterState.RUNNING.getValue());

// 4. 按框架查询
List<ClusterInfoEntity> ddpClusters = 
    clusterInfoService.getClusterByFrameCode("DDP-1.2.0");
```

### 8.3 集群删除示例

```java
// 1. 先停止集群
clusterInfoService.updateClusterState(clusterId, ClusterState.STOP.getValue());

// 2. 确认所有服务已停止
// ... 停止所有服务实例 ...

// 3. 删除集群
clusterInfoService.deleteCluster(Arrays.asList(clusterId));

// 4. 系统会异步处理删除操作
```

## 九、总结

### 9.1 核心功能

ClusterInfoService 提供了集群管理的核心功能：
1. ✅ **集群生命周期管理**: 创建、查询、更新、删除
2. ✅ **状态管理**: 支持多种集群状态流转
3. ✅ **资源初始化**: 自动创建默认配置和资源
4. ✅ **全局变量管理**: 统一管理集群配置变量
5. ✅ **告警集成**: 自动关联告警组
6. ✅ **安全控制**: 权限管理和数据校验

### 9.2 设计特点

**1. 完整的初始化流程**:
- 创建集群时自动初始化 YARN 调度器、节点标签、队列、机架等配置
- 确保新集群即刻可用

**2. 灵活的状态管理**:
- 使用枚举类型管理状态
- 支持状态流转控制

**3. 异步删除机制**:
- 使用 Actor 模型异步处理删除操作
- 避免长时间阻塞请求

**4. 全局变量缓存**:
- 提前计算和缓存配置变量
- 提高配置生成效率

### 9.3 改进建议

**1. 批量操作优化**:
```java
// 当前：循环查询用户
for (ClusterInfoEntity clusterInfoEntity : list) {
    List<UserInfoEntity> userList = clusterUserService.getAllClusterManagerByClusterId(...);
    // ...
}

// 建议：批量查询
Map<Integer, List<UserInfoEntity>> userMap = 
    clusterUserService.batchGetUsersByClusterIds(clusterIds);
```

**2. 异常处理增强**:
```java
// 添加更详细的异常信息
try {
    this.save(clusterInfo);
} catch (DataAccessException e) {
    log.error("保存集群信息失败", e);
    return Result.error("数据库操作失败: " + e.getMessage());
}
```

**3. 配置参数化**:
```java
// 将硬编码的路径配置化
@Value("${cluster.install.path}")
private String installPath;
```

**4. 审计日志**:
```java
// 添加操作日志
@AfterReturning("execution(* saveCluster(..))")
public void logClusterCreation(JoinPoint joinPoint) {
    auditLogService.log("创建集群", clusterInfo);
}
```

### 9.4 最佳实践

**1. 使用服务时注意事务边界**:
```java
@Transactional
public void complexOperation() {
    clusterInfoService.saveCluster(cluster);
    // 其他相关操作
}
```

**2. 合理使用缓存**:
```java
// 频繁访问的数据应缓存
GlobalVariables.get(clusterId);
```

**3. 状态检查**:
```java
// 操作前检查集群状态
if (ClusterState.RUNNING.equals(cluster.getClusterState())) {
    // 执行操作
}
```

**4. 错误处理**:
```java
Result result = clusterInfoService.saveCluster(cluster);
if (result.getCode() != 200) {
    log.error("集群创建失败: {}", result.getMsg());
    // 处理错误
}
```

---

**文档版本**: v1.0  
**创建日期**: 2025-11-15  
**适用版本**: DataSophon 1.2.0+  
**维护者**: DataSophon 源码分析团队
