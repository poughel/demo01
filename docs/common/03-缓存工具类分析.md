# DataSophon Common 模块 - 缓存工具类详解

## 一、文件概述

**文件路径**: `datasophon-common/src/main/java/com/datasophon/common/cache/CacheUtils.java`

**功能定位**: 提供简单高效的内存缓存功能，用于临时存储频繁访问的数据

**核心特性**:
- 基于 Hutool 工具库的 LRU 缓存实现
- 线程安全的缓存操作
- 支持多种数据类型的存取
- 固定容量4096个条目

## 二、源码详解

### 2.1 完整源码

```java
package com.datasophon.common.cache;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import cn.hutool.cache.Cache;
import cn.hutool.cache.CacheUtil;

/**
 * Cache工具类
 */
public class CacheUtils {
    
    private static Logger logger = LoggerFactory.getLogger(CacheUtils.class);
    
    // 使用 LRU 缓存，容量为 4096
    private static Cache<String, Object> cache = CacheUtil.newLRUCache(4096);
    
    /**
     * 获取缓存值
     * @param key 缓存键
     * @return 缓存值，不存在返回null
     */
    public static Object get(String key) {
        Object data = cache.get(key);
        return data;
    }
    
    /**
     * 存储缓存值
     * @param key 缓存键
     * @param value 缓存值
     */
    public static void put(String key, Object value) {
        cache.put(key, value);
    }
    
    /**
     * 检查缓存键是否存在
     * @param key 缓存键
     * @return 是否存在
     */
    public static boolean constainsKey(String key) {
        return cache.containsKey(key);
    }
    
    /**
     * 移除缓存项
     * @param key 缓存键
     */
    public static void removeKey(String key) {
        cache.remove(key);
    }
    
    /**
     * 获取Integer类型缓存值
     * @param key 缓存键
     * @return Integer值
     */
    public static Integer getInteger(String key) {
        Object data = cache.get(key);
        return (Integer) data;
    }
    
    /**
     * 获取Boolean类型缓存值
     * @param key 缓存键
     * @return Boolean值
     */
    public static Boolean getBoolean(String key) {
        Object data = cache.get(key);
        return (Boolean) data;
    }
    
    /**
     * 获取String类型缓存值
     * @param key 缓存键
     * @return String值
     */
    public static String getString(String key) {
        Object data = cache.get(key);
        return (String) data;
    }
}
```

### 2.2 依赖库分析

#### Hutool Cache 模块

**选择 Hutool 的原因**:
1. **轻量级**: 无需引入重量级缓存框架
2. **开箱即用**: 简单API，快速上手
3. **功能完善**: 提供多种缓存策略
4. **性能优秀**: 基于 ConcurrentHashMap 实现

**LRU 缓存特性**:
- **Least Recently Used**: 最近最少使用淘汰策略
- **固定容量**: 达到容量上限时自动淘汰
- **线程安全**: 支持并发访问
- **时间复杂度**: O(1) 读写性能

## 三、核心功能分析

### 3.1 缓存初始化

```java
private static Cache<String, Object> cache = CacheUtil.newLRUCache(4096);
```

**设计要点**:
- **静态实例**: 全局唯一缓存实例
- **容量设置**: 4096个条目，约占用内存根据对象大小而定
- **泛型定义**: Key 为 String，Value 为 Object（支持任意类型）

**容量选择分析**:
- 4096 = 2^12，是2的幂次，利于哈希表优化
- 对于中小型应用，4096个条目通常足够
- 大对象场景下需要评估内存占用

### 3.2 基础存取操作

#### 存储数据 - put()

```java
public static void put(String key, Object value) {
    cache.put(key, value);
}
```

**使用示例**:
```java
// 缓存主机信息
CacheUtils.put("host_" + hostId, hostInfo);

// 缓存配置信息
CacheUtils.put("config_" + clusterId, configMap);

// 缓存用户会话
CacheUtils.put("session_" + sessionId, userInfo);
```

**注意事项**:
- Value 可以是任意对象
- 如果 Key 已存在，会覆盖旧值
- 达到容量上限时，LRU会自动淘汰最久未使用的项

#### 获取数据 - get()

```java
public static Object get(String key) {
    Object data = cache.get(key);
    return data;
}
```

**使用示例**:
```java
// 获取并类型转换
HostInfo hostInfo = (HostInfo) CacheUtils.get("host_" + hostId);

// 判空处理
Object data = CacheUtils.get(key);
if (data != null) {
    // 处理数据
}
```

### 3.3 类型安全的获取方法

#### 获取 Integer - getInteger()

```java
public static Integer getInteger(String key) {
    Object data = cache.get(key);
    return (Integer) data;
}
```

**使用场景**:
```java
// 缓存集群ID
CacheUtils.put("current_cluster_id", 1);
Integer clusterId = CacheUtils.getInteger("current_cluster_id");

// 缓存状态码
CacheUtils.put("service_state_" + serviceId, 3);
Integer state = CacheUtils.getInteger("service_state_" + serviceId);
```

**类型转换风险**:
```java
// ❌ 危险：如果实际类型不是 Integer，会抛出 ClassCastException
CacheUtils.put("key", "string_value");
Integer value = CacheUtils.getInteger("key");  // 运行时异常

// ✅ 安全：使用前检查类型或捕获异常
try {
    Integer value = CacheUtils.getInteger("key");
} catch (ClassCastException e) {
    logger.error("类型转换失败", e);
}
```

#### 获取 Boolean - getBoolean()

```java
public static Boolean getBoolean(String key) {
    Object data = cache.get(key);
    return (Boolean) data;
}
```

**使用场景**:
```java
// 缓存功能开关
CacheUtils.put("enable_ha", true);
Boolean enableHA = CacheUtils.getBoolean("enable_ha");

// 缓存权限标识
CacheUtils.put("is_admin_" + userId, false);
Boolean isAdmin = CacheUtils.getBoolean("is_admin_" + userId);
```

#### 获取 String - getString()

```java
public static String getString(String key) {
    Object data = cache.get(key);
    return (String) data;
}
```

**使用场景**:
```java
// 缓存主机名
CacheUtils.put("hostname_" + hostId, "node01");
String hostname = CacheUtils.getString("hostname_" + hostId);

// 缓存Token
CacheUtils.put("token_" + userId, "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...");
String token = CacheUtils.getString("token_" + userId);
```

### 3.4 缓存管理操作

#### 检查键存在 - containsKey()

```java
public static boolean constainsKey(String key) {
    return cache.containsKey(key);
}
```

**注意**: 方法名拼写错误（constainsKey应为containsKey），这是一个小bug

**使用示例**:
```java
// 避免重复加载
if (!CacheUtils.constainsKey("config_" + clusterId)) {
    // 从数据库加载配置
    Config config = loadConfigFromDB(clusterId);
    CacheUtils.put("config_" + clusterId, config);
}

// 条件处理
if (CacheUtils.constainsKey("lock_" + resourceId)) {
    logger.warn("资源已被锁定");
    return;
}
```

#### 移除缓存 - removeKey()

```java
public static void removeKey(String key) {
    cache.remove(key);
}
```

**使用场景**:
```java
// 用户登出，清除会话
CacheUtils.removeKey("session_" + sessionId);

// 配置更新，清除缓存
CacheUtils.removeKey("config_" + clusterId);

// 清理过期数据
CacheUtils.removeKey("temp_data_" + taskId);
```

## 四、典型应用场景

### 4.1 主机信息缓存

```java
public class HostService {
    
    /**
     * 获取主机信息（带缓存）
     */
    public HostInfo getHostInfo(Integer hostId) {
        String cacheKey = "host_" + hostId;
        
        // 先从缓存获取
        if (CacheUtils.constainsKey(cacheKey)) {
            return (HostInfo) CacheUtils.get(cacheKey);
        }
        
        // 缓存未命中，从数据库查询
        HostInfo hostInfo = hostMapper.selectById(hostId);
        
        // 存入缓存
        if (hostInfo != null) {
            CacheUtils.put(cacheKey, hostInfo);
        }
        
        return hostInfo;
    }
    
    /**
     * 更新主机信息（清除缓存）
     */
    public void updateHostInfo(HostInfo hostInfo) {
        // 更新数据库
        hostMapper.updateById(hostInfo);
        
        // 清除缓存
        CacheUtils.removeKey("host_" + hostInfo.getId());
    }
}
```

### 4.2 集群配置缓存

```java
public class ClusterConfigService {
    
    /**
     * 获取集群配置（带缓存）
     */
    public Map<String, String> getClusterConfig(Integer clusterId) {
        String cacheKey = "cluster_config_" + clusterId;
        
        // 尝试从缓存获取
        Object cached = CacheUtils.get(cacheKey);
        if (cached != null) {
            return (Map<String, String>) cached;
        }
        
        // 从数据库加载
        Map<String, String> config = loadConfigFromDB(clusterId);
        
        // 缓存配置（配置不会频繁变更，适合缓存）
        CacheUtils.put(cacheKey, config);
        
        return config;
    }
    
    /**
     * 更新集群配置（清除缓存）
     */
    public void updateClusterConfig(Integer clusterId, Map<String, String> config) {
        // 保存到数据库
        saveConfigToDB(clusterId, config);
        
        // 清除缓存，强制下次重新加载
        CacheUtils.removeKey("cluster_config_" + clusterId);
    }
}
```

### 4.3 服务状态缓存

```java
public class ServiceStateMonitor {
    
    /**
     * 缓存服务状态，减少数据库查询
     */
    public void cacheServiceState(Integer serviceId, Integer state) {
        String cacheKey = "service_state_" + serviceId;
        CacheUtils.put(cacheKey, state);
    }
    
    /**
     * 获取服务状态
     */
    public Integer getServiceState(Integer serviceId) {
        String cacheKey = "service_state_" + serviceId;
        
        // 优先从缓存获取
        Integer state = CacheUtils.getInteger(cacheKey);
        if (state != null) {
            return state;
        }
        
        // 缓存未命中，查询数据库
        state = serviceMapper.getState(serviceId);
        
        // 更新缓存
        if (state != null) {
            CacheUtils.put(cacheKey, state);
        }
        
        return state;
    }
}
```

### 4.4 临时数据存储

```java
public class TaskExecutor {
    
    /**
     * 执行长时间任务，使用缓存传递中间结果
     */
    public void executeAsyncTask(String taskId) {
        // 缓存任务状态
        CacheUtils.put("task_status_" + taskId, "RUNNING");
        CacheUtils.put("task_progress_" + taskId, 0);
        
        // 异步执行任务
        new Thread(() -> {
            try {
                for (int i = 1; i <= 100; i++) {
                    // 更新进度
                    CacheUtils.put("task_progress_" + taskId, i);
                    Thread.sleep(100);
                }
                
                // 任务完成
                CacheUtils.put("task_status_" + taskId, "SUCCESS");
            } catch (Exception e) {
                CacheUtils.put("task_status_" + taskId, "FAILED");
            }
        }).start();
    }
    
    /**
     * 查询任务进度
     */
    public Map<String, Object> getTaskProgress(String taskId) {
        Map<String, Object> result = new HashMap<>();
        result.put("status", CacheUtils.getString("task_status_" + taskId));
        result.put("progress", CacheUtils.getInteger("task_progress_" + taskId));
        return result;
    }
    
    /**
     * 清理任务缓存
     */
    public void cleanTaskCache(String taskId) {
        CacheUtils.removeKey("task_status_" + taskId);
        CacheUtils.removeKey("task_progress_" + taskId);
    }
}
```

### 4.5 分布式锁实现

```java
public class DistributedLock {
    
    /**
     * 尝试获取锁
     */
    public boolean tryLock(String resourceId, String ownerId) {
        String lockKey = "lock_" + resourceId;
        
        // 检查锁是否已被持有
        if (CacheUtils.constainsKey(lockKey)) {
            return false;
        }
        
        // 获取锁
        CacheUtils.put(lockKey, ownerId);
        return true;
    }
    
    /**
     * 释放锁
     */
    public void unlock(String resourceId, String ownerId) {
        String lockKey = "lock_" + resourceId;
        
        // 验证锁的持有者
        String lockOwner = CacheUtils.getString(lockKey);
        if (ownerId.equals(lockOwner)) {
            CacheUtils.removeKey(lockKey);
        }
    }
}
```

**注意**: 此实现仅适用于单机环境，分布式环境需要使用 Redis 等分布式缓存

## 五、性能分析

### 5.1 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| put() | O(1) | 基于 HashMap 的put操作 |
| get() | O(1) | 基于 HashMap 的get操作 |
| containsKey() | O(1) | 基于 HashMap 的containsKey操作 |
| remove() | O(1) | 基于 HashMap 的remove操作 |

### 5.2 空间复杂度

**内存占用估算**:
- 容量: 4096个条目
- Key: 假设平均长度20字符，约20B
- Value: 根据对象类型不同，差异很大
  - 简单类型（Integer/Boolean）: 16-24B
  - 字符串: 40B + 字符长度
  - 复杂对象: 几百B到几KB

**极端情况**:
- 最小: 4096 × (20 + 16) ≈ 144KB
- 中等: 4096 × (20 + 200) ≈ 880KB
- 最大: 4096 × (20 + 5000) ≈ 20MB

### 5.3 LRU 淘汰策略

**工作原理**:
1. 维护访问顺序链表
2. 每次访问将元素移到链表头部
3. 达到容量上限时，删除链表尾部元素

**示例流程**:
```
容量=3，当前缓存: []

put(A) -> [A]
put(B) -> [B, A]
put(C) -> [C, B, A]
get(A) -> [A, C, B]  // A移到头部
put(D) -> [D, A, C]  // B被淘汰（最久未使用）
```

## 六、存在的问题与改进建议

### 6.1 现有问题

#### 问题1: 方法名拼写错误
```java
// 错误拼写
public static boolean constainsKey(String key)

// 应该是
public static boolean containsKey(String key)
```

#### 问题2: 缺少过期时间支持
```java
// 当前实现无法设置过期时间
CacheUtils.put("temp_key", value);
// 无法自动过期，需要手动清理
```

#### 问题3: 缺少批量操作
```java
// 不支持批量存储
Map<String, Object> batchData = new HashMap<>();
// 只能逐个put
```

#### 问题4: 类型转换不安全
```java
// 可能抛出 ClassCastException
Integer value = CacheUtils.getInteger("key");
```

#### 问题5: 缺少缓存统计
```java
// 无法查看缓存命中率、淘汰次数等统计信息
```

### 6.2 改进方案

#### 改进1: 修复拼写错误

```java
/**
 * 检查缓存键是否存在
 * @param key 缓存键
 * @return 是否存在
 */
public static boolean containsKey(String key) {
    return cache.containsKey(key);
}

// 保留旧方法用于兼容（标记为废弃）
@Deprecated
public static boolean constainsKey(String key) {
    return containsKey(key);
}
```

#### 改进2: 支持过期时间

```java
/**
 * 存储带过期时间的缓存
 * @param key 缓存键
 * @param value 缓存值
 * @param timeout 过期时间（秒）
 */
public static void put(String key, Object value, long timeout) {
    // 使用 Hutool 的 TimedCache
    cache.put(key, value, timeout * 1000);
}

// 使用示例
CacheUtils.put("temp_key", value, 300);  // 5分钟后过期
```

#### 改进3: 支持批量操作

```java
/**
 * 批量存储
 * @param map 键值对映射
 */
public static void putAll(Map<String, Object> map) {
    if (map != null && !map.isEmpty()) {
        map.forEach((k, v) -> cache.put(k, v));
    }
}

/**
 * 批量获取
 * @param keys 键集合
 * @return 键值对映射
 */
public static Map<String, Object> getAll(Collection<String> keys) {
    Map<String, Object> result = new HashMap<>();
    if (keys != null && !keys.isEmpty()) {
        keys.forEach(key -> {
            Object value = cache.get(key);
            if (value != null) {
                result.put(key, value);
            }
        });
    }
    return result;
}
```

#### 改进4: 安全的类型转换

```java
/**
 * 安全获取 Integer 值
 * @param key 缓存键
 * @param defaultValue 默认值
 * @return Integer值，转换失败返回默认值
 */
public static Integer getInteger(String key, Integer defaultValue) {
    try {
        Object data = cache.get(key);
        if (data == null) {
            return defaultValue;
        }
        return (Integer) data;
    } catch (ClassCastException e) {
        logger.error("类型转换失败: key={}", key, e);
        return defaultValue;
    }
}

/**
 * 泛型方法，支持任意类型
 * @param key 缓存键
 * @param clazz 目标类型
 * @return 转换后的值
 */
public static <T> T get(String key, Class<T> clazz) {
    try {
        Object data = cache.get(key);
        if (data == null) {
            return null;
        }
        return clazz.cast(data);
    } catch (ClassCastException e) {
        logger.error("类型转换失败: key={}, target={}", key, clazz, e);
        return null;
    }
}
```

#### 改进5: 添加缓存统计

```java
private static AtomicLong hitCount = new AtomicLong(0);
private static AtomicLong missCount = new AtomicLong(0);

public static Object get(String key) {
    Object data = cache.get(key);
    if (data != null) {
        hitCount.incrementAndGet();
    } else {
        missCount.incrementAndGet();
    }
    return data;
}

/**
 * 获取缓存统计信息
 */
public static Map<String, Object> getStats() {
    Map<String, Object> stats = new HashMap<>();
    long hit = hitCount.get();
    long miss = missCount.get();
    long total = hit + miss;
    
    stats.put("hitCount", hit);
    stats.put("missCount", miss);
    stats.put("totalRequests", total);
    stats.put("hitRate", total > 0 ? (double) hit / total : 0.0);
    stats.put("cacheSize", cache.size());
    
    return stats;
}
```

#### 改进6: 支持缓存清空

```java
/**
 * 清空所有缓存
 */
public static void clear() {
    cache.clear();
    logger.info("缓存已清空");
}

/**
 * 批量删除匹配的缓存
 * @param pattern 键的匹配模式
 */
public static void removeByPattern(String pattern) {
    Iterator<String> iterator = cache.iterator();
    while (iterator.hasNext()) {
        String key = iterator.next();
        if (key.matches(pattern)) {
            cache.remove(key);
        }
    }
}
```

## 七、最佳实践

### 7.1 Key 命名规范

```java
// ✅ 推荐：使用前缀 + 分隔符 + ID
String hostKey = "host_" + hostId;
String configKey = "config_" + clusterId;
String sessionKey = "session_" + sessionId;

// ❌ 不推荐：不明确的Key
String key1 = "h" + hostId;
String key2 = clusterId.toString();
```

### 7.2 避免缓存穿透

```java
// ❌ 不推荐：未检查缓存，每次都查数据库
public HostInfo getHost(Integer hostId) {
    return hostMapper.selectById(hostId);
}

// ✅ 推荐：使用缓存减少数据库访问
public HostInfo getHost(Integer hostId) {
    String cacheKey = "host_" + hostId;
    
    // 先查缓存
    if (CacheUtils.constainsKey(cacheKey)) {
        return (HostInfo) CacheUtils.get(cacheKey);
    }
    
    // 缓存未命中，查数据库
    HostInfo hostInfo = hostMapper.selectById(hostId);
    
    // 更新缓存
    if (hostInfo != null) {
        CacheUtils.put(cacheKey, hostInfo);
    }
    
    return hostInfo;
}
```

### 7.3 及时清理缓存

```java
// ✅ 推荐：数据更新时清除缓存
public void updateHost(HostInfo hostInfo) {
    // 更新数据库
    hostMapper.updateById(hostInfo);
    
    // 清除缓存，确保数据一致性
    CacheUtils.removeKey("host_" + hostInfo.getId());
}

// ✅ 推荐：任务完成后清理临时缓存
public void onTaskComplete(String taskId) {
    // 业务处理
    // ...
    
    // 清理临时缓存
    CacheUtils.removeKey("task_status_" + taskId);
    CacheUtils.removeKey("task_progress_" + taskId);
}
```

### 7.4 异常处理

```java
// ✅ 推荐：处理类型转换异常
public Integer getServiceState(Integer serviceId) {
    try {
        return CacheUtils.getInteger("service_state_" + serviceId);
    } catch (ClassCastException e) {
        logger.error("缓存类型转换失败", e);
        // 清除错误的缓存
        CacheUtils.removeKey("service_state_" + serviceId);
        return null;
    }
}
```

## 八、总结

### 核心优势

1. **简单易用**: API简洁，上手快
2. **高性能**: O(1) 时间复杂度，基于 LRU 策略
3. **线程安全**: 支持并发访问
4. **轻量级**: 无需额外的缓存服务

### 适用场景

✅ **适合**:
- 单机应用的临时数据缓存
- 频繁读取的小数据量缓存
- 不需要持久化的缓存场景
- 开发测试环境的快速缓存

❌ **不适合**:
- 分布式环境（需要 Redis 等分布式缓存）
- 需要持久化的数据
- 大数据量缓存（受内存限制）
- 需要复杂过期策略的场景

### 改进建议

1. 修复方法名拼写错误
2. 增加过期时间支持
3. 完善类型安全机制
4. 添加缓存统计功能
5. 支持批量操作
6. 增加缓存清空功能

---

**文档版本**: v1.0  
**最后更新**: 2025-11-15  
**分析人员**: DataSophon 源码分析团队
