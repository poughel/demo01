# DataSophon Common 模块 - 工具类详解

## 一、模块概述

**模块路径**: `datasophon-common/src/main/java/com/datasophon/common/utils/`

**功能定位**: 提供系统通用的工具方法，简化常见操作，提高代码复用性

**工具类列表** (13个):
1. **Result.java** - 统一响应结果封装
2. **ExecResult.java** - Shell命令执行结果封装
3. **ShellUtils.java** - Shell命令执行工具
4. **FileUtils.java** - 文件操作工具
5. **CollectionUtils.java** - 集合操作工具
6. **PlaceholderUtils.java** - 占位符替换工具
7. **PropertyUtils.java** - 配置文件读取工具
8. **HostUtils.java** - 主机信息工具
9. **EncryptionUtils.java** - 加密解密工具
10. **IOUtils.java** - IO操作工具
11. **ThrowableUtils.java** - 异常处理工具
12. **PromInfoUtils.java** - Prometheus信息处理工具
13. **OlapUtils.java** - OLAP数据库操作工具

## 二、核心工具类详解

### 2.1 Result - 统一响应结果封装

#### 类定义

```java
@Data
public class Result extends HashMap<String, Object> {
    private Integer code;
    private String msg;
    private Object data;
}
```

**设计特点**:
- 继承自 HashMap，支持灵活的 key-value 存储
- 提供静态工厂方法，便于创建响应对象
- 支持链式调用，代码简洁优雅
- 统一 API 响应格式

#### 核心方法

##### 成功响应

```java
// 简单成功响应
public static Result success() {
    Result result = new Result();
    result.put("code", 200);
    result.put("msg", "success");
    return result;
}

// 带数据的成功响应
public static Result success(Object data) {
    Result result = new Result();
    result.put("code", 200);
    result.put("msg", "success");
    result.put("data", data);
    return result;
}

// 空数据成功响应
public static Result successEmptyCount() {
    Result result = success(new ArrayList<>(0));
    result.put("total", 0);
    return result;
}

// 从Map创建成功响应
public static Result success(Map<String, Object> map) {
    Result result = new Result();
    result.putAll(map);
    return result;
}
```

##### 错误响应

```java
// 默认错误响应
public static Result error() {
    return error(500, "未知异常，请联系管理员");
}

// 自定义错误消息
public static Result error(String msg) {
    return error(500, msg);
}

// 自定义错误码和消息
public static Result error(int code, String msg) {
    Result result = new Result();
    result.put("code", code);
    result.put("msg", msg);
    return result;
}
```

##### 链式调用

```java
@Override
public Result put(String key, Object value) {
    super.put(key, value);
    return this;  // 返回this，支持链式调用
}
```

##### 工具方法

```java
// 获取状态码
public Integer getCode() {
    return (Integer) this.get(Constants.CODE);
}

// 获取数据
public Object getData() {
    return this.get(Constants.DATA);
}

// 判断是否成功
public boolean isSuccess() {
    return this.getCode() == 200;
}
```

#### 使用示例

```java
// Controller 层使用
@GetMapping("/cluster/list")
public Result getClusterList() {
    List<ClusterInfo> list = clusterService.list();
    return Result.success(list);
}

@PostMapping("/cluster/save")
public Result saveCluster(@RequestBody ClusterInfo cluster) {
    if (cluster.getName() == null) {
        return Result.error("集群名称不能为空");
    }
    clusterService.save(cluster);
    return Result.success();
}

// 链式调用，添加多个字段
@GetMapping("/cluster/page")
public Result getClusterPage(int page, int size) {
    List<ClusterInfo> list = clusterService.page(page, size);
    int total = clusterService.count();
    
    return Result.success()
        .put("list", list)
        .put("total", total)
        .put("page", page)
        .put("size", size);
}

// 业务层判断结果
Result result = clusterService.createCluster(cluster);
if (result.isSuccess()) {
    logger.info("集群创建成功");
} else {
    logger.error("集群创建失败: {}", result.get("msg"));
}
```

#### 响应格式

```json
// 成功响应
{
  "code": 200,
  "msg": "success",
  "data": {
    "id": 1,
    "name": "cluster01"
  }
}

// 错误响应
{
  "code": 500,
  "msg": "集群名称不能为空"
}

// 分页响应
{
  "code": 200,
  "msg": "success",
  "list": [...],
  "total": 100,
  "page": 1,
  "size": 10
}
```

### 2.2 ExecResult - 命令执行结果封装

#### 类定义

```java
public class ExecResult implements Serializable {
    private boolean execResult = false;  // 执行是否成功
    private String execOut;              // 标准输出
    private String execErrOut;           // 错误输出
}
```

**用途**: 封装 Shell 命令执行的结果信息

#### 使用示例

```java
ExecResult result = ShellUtils.exceShell("ls -la /opt");
if (result.getExecResult()) {
    logger.info("命令执行成功，输出: {}", result.getExecOut());
} else {
    logger.error("命令执行失败，错误: {}", result.getExecErrOut());
}
```

### 2.3 ShellUtils - Shell命令执行工具

#### 功能概述

提供 Shell 命令执行的封装方法，支持同步执行、异步执行、超时控制等功能。

#### 核心方法

##### 基础命令执行

```java
/**
 * 执行Shell命令
 * @param pathOrCommand 脚本路径或命令
 * @return 执行结果
 */
public static ExecResult exceShell(String pathOrCommand) {
    ExecResult result = new ExecResult();
    StringBuffer stringBuffer = new StringBuffer();
    try {
        // 执行脚本
        Process ps = Runtime.getRuntime().exec(new String[]{"sh", "-c", pathOrCommand});
        
        // 读取输出
        BufferedInputStream in = new BufferedInputStream(ps.getInputStream());
        BufferedReader br = new BufferedReader(new InputStreamReader(in));
        String line;
        while ((line = br.readLine()) != null) {
            stringBuffer.append(line);
            stringBuffer.append(System.lineSeparator());
        }
        in.close();
        br.close();
        
        String execOut = stringBuffer.toString();
        int exitValue = ps.waitFor();
        
        if (0 == exitValue) {
            logger.info("{} command exec out is : {} {}", pathOrCommand, System.lineSeparator(), execOut);
            result.setExecResult(true);
            result.setExecOut(execOut);
        } else {
            result.setExecOut("call shell failed. error code is :" + exitValue);
            logger.error("{} command exec out is : {} {}", pathOrCommand, System.lineSeparator(), execOut);
        }
        
    } catch (Exception e) {
        result.setExecOut(e.getMessage());
        logger.error(e.getMessage(), e);
    }
    return result;
}
```

**使用场景**:
```java
// 查看文件列表
ExecResult result = ShellUtils.exceShell("ls -la /opt/hadoop");

// 检查进程
ExecResult result = ShellUtils.exceShell("ps aux | grep java");

// 执行脚本
ExecResult result = ShellUtils.exceShell("/opt/scripts/start_service.sh");
```

##### 带超时的命令执行

```java
/**
 * 带超时控制的命令执行
 * @param workPath 工作目录
 * @param command 命令列表
 * @param timeout 超时时间（秒）
 * @return 执行结果
 */
public static ExecResult execWithStatus(String workPath, List<String> command, long timeout) {
    Process process = null;
    ExecResult result = new ExecResult();
    try {
        processBuilder.directory(new File(workPath));
        processBuilder.command(command);
        processBuilder.redirectErrorStream(true);
        process = processBuilder.start();
        
        getOutput(process);
        boolean execResult = process.waitFor(timeout, TimeUnit.SECONDS);
        
        if (execResult && process.exitValue() == 0) {
            logger.info("script execute success");
            result.setExecResult(true);
            result.setExecOut("script execute success");
        } else {
            result.setExecOut("script execute failed");
        }
        return result;
    } catch (Exception e) {
        result.setExecErrOut(e.getMessage());
        logger.error(e.getMessage(), e);
    }
    return result;
}
```

**使用场景**:
```java
// 执行可能耗时的命令，设置60秒超时
List<String> command = Arrays.asList("sh", "/opt/scripts/deploy.sh");
ExecResult result = ShellUtils.execWithStatus("/opt", command, 60);
```

##### 获取CPU架构

```java
/**
 * 获取CPU架构 (x86_64/aarch64)
 */
public static String getCpuArchitecture() {
    try {
        Process ps = Runtime.getRuntime().exec("arch");
        StringBuffer stringBuffer = new StringBuffer();
        int exitValue = ps.waitFor();
        
        if (0 == exitValue) {
            BufferedInputStream in = new BufferedInputStream(ps.getInputStream());
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String line;
            while ((line = br.readLine()) != null) {
                logger.info("脚本返回的数据如下： " + line);
                stringBuffer.append(line);
            }
            in.close();
            br.close();
            return stringBuffer.toString();
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
```

**使用场景**:
```java
// 根据架构选择对应的JDK包
String arch = ShellUtils.getCpuArchitecture();
String jdkPackage = "x86_64".equals(arch) ? Constants.X86JDK : Constants.ARMJDK;
```

##### 文件权限管理

```java
/**
 * 修改文件权限
 */
public static void addChmod(String path, String chmod) {
    ArrayList<String> command = new ArrayList<>();
    command.add("chmod");
    command.add("-R");
    command.add(chmod);
    command.add(path);
    execWithStatus(Constants.INSTALL_PATH, command, 60, logger);
}

/**
 * 修改文件所有者
 */
public static void addChown(String path, String user, String group) {
    ArrayList<String> command = new ArrayList<>();
    command.add("chown");
    command.add("-R");
    command.add(user + ":" + group);
    command.add(path);
    execWithStatus(Constants.INSTALL_PATH, command, 60, logger);
}
```

**使用场景**:
```java
// 安装服务后设置权限
ShellUtils.addChmod("/opt/hadoop", "755");
ShellUtils.addChown("/opt/hadoop", "hadoop", "hadoop");
```

#### 输出日志处理

```java
/**
 * 异步读取进程输出
 */
public static void getOutput(Process process, Logger logger) {
    ExecutorService getOutputLogService = Executors.newSingleThreadExecutor();
    
    getOutputLogService.submit(() -> {
        // 读取标准输出
        BufferedReader inReader = null;
        try {
            inReader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line;
            StringBuffer stringBuffer = new StringBuffer();
            while ((line = inReader.readLine()) != null) {
                stringBuffer.append(line);
                stringBuffer.append(System.lineSeparator());
            }
            logger.info(stringBuffer.toString());
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        } finally {
            closeQuietly(inReader);
        }
        
        // 读取错误输出
        BufferedReader errorReader = null;
        try {
            errorReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));
            String line;
            StringBuffer stringBuffer = new StringBuffer();
            while ((line = errorReader.readLine()) != null) {
                stringBuffer.append(line);
                stringBuffer.append(System.lineSeparator());
            }
            logger.error(stringBuffer.toString());
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        } finally {
            closeQuietly(errorReader);
        }
    });
    getOutputLogService.shutdown();
}
```

**设计要点**:
- 异步处理，避免阻塞主线程
- 分别处理标准输出和错误输出
- 使用线程池执行
- 安全关闭资源

### 2.4 FileUtils - 文件操作工具

#### 核心功能

1. **文件MD5计算** - 大文件友好
2. **tar.gz压缩包读取** - 无需解压
3. **读取文件首行**
4. **路径拼接**

#### 详细方法

##### MD5计算

```java
/**
 * 计算文件MD5值（支持大文件）
 * @param file 文件对象
 * @return MD5字符串
 */
public static String md5(File file) {
    try (FileInputStream fileInputStream = new FileInputStream(file)) {
        MessageDigest md5 = MessageDigest.getInstance("MD5");
        
        byte[] buffer = new byte[8192];
        int length;
        while ((length = fileInputStream.read(buffer)) != -1) {
            md5.update(buffer, 0, length);
        }
        return new String(Hex.encodeHex(md5.digest()));
    } catch (Exception e) {
        throw new IllegalStateException(e);
    }
}
```

**特点**:
- 分块读取，适用于大文件
- 内存占用固定（8KB缓冲区）
- 自动资源管理（try-with-resources）

**使用场景**:
```java
// 校验安装包完整性
File workerPackage = new File("/opt/datasophon-worker.tar.gz");
String actualMd5 = FileUtils.md5(workerPackage);
String expectedMd5 = "a1b2c3d4...";

if (actualMd5.equals(expectedMd5)) {
    logger.info("安装包校验通过");
} else {
    logger.error("安装包MD5不匹配，可能已损坏");
}
```

##### 读取压缩包中的文件

```java
/**
 * 从tar.gz压缩包中读取文本文件（无需解压）
 * @param targz 压缩包文件
 * @param name 要读取的文件名
 * @param charset 字符编码
 * @return 文件内容
 */
public static String readTargzTextFile(File targz, String name, Charset charset) throws IOException {
    String content = null;
    TarEntry tarEntry = null;
    try (
        TarInputStream tarInputStream = new TarInputStream(new GZIPInputStream(new FileInputStream(targz)));
        BufferedReader reader = new BufferedReader(new InputStreamReader(tarInputStream, charset));
    ) {
        boolean hasNext = reader.readLine() != null;
        if (hasNext) {
            return null;
        }
        while ((tarEntry = tarInputStream.getNextEntry()) != null) {
            String entryName = tarEntry.getName();
            if (tarEntry.isDirectory()) {
                continue;
            }
            if (entryName.endsWith(name)) {
                content = CharStreams.toString(reader);
                break;
            }
        }
    }
    return content;
}
```

**使用场景**:
```java
// 读取压缩包中的版本信息，无需完整解压
File servicePackage = new File("/opt/packages/hadoop-3.2.0.tar.gz");
String versionInfo = FileUtils.readTargzTextFile(servicePackage, "VERSION", StandardCharsets.UTF_8);
logger.info("服务版本: {}", versionInfo);
```

##### 读取文件首行

```java
/**
 * 读取文件的第一行（非空行）
 * @param file 文件对象
 * @return 第一行内容
 */
public static String readFirstLine(File file) throws Exception {
    final String firstLine = CharStreams.readLines(new FileReader(file), new LineProcessor<String>() {
        String firstLine = null;
        
        @Override
        public boolean processLine(String line) throws IOException {
            this.firstLine = line;
            // 第一行非空则返回
            return StringUtils.trimToNull(line) == null;
        }
        
        @Override
        public String getResult() {
            return firstLine;
        }
    });
    return firstLine;
}
```

**使用场景**:
```java
// 读取配置文件首行注释
File configFile = new File("/opt/hadoop/etc/hadoop/core-site.xml");
String header = FileUtils.readFirstLine(configFile);
```

##### 路径拼接

```java
/**
 * 智能拼接路径，自动处理分隔符
 * @param paths 路径片段
 * @return 拼接后的路径
 */
public static String concatPath(String... paths) {
    StringBuilder stringBuilder = new StringBuilder();
    for (int i = 0; i < paths.length; i++) {
        String path = paths[i];
        if (StringUtils.isBlank(path)) {
            continue;
        }
        path = StringUtils.appendIfMissing(path, "/");
        if (i != 0) {
            path = StringUtils.removeStart(path, "/");
        }
        if (i == paths.length - 1) {
            path = StringUtils.removeEnd(path, "/");
        }
        stringBuilder.append(path);
    }
    return StringUtils.removeEnd(stringBuilder.toString(), "/");
}
```

**使用场景**:
```java
// 构建配置文件路径
String confPath = FileUtils.concatPath("/opt", "hadoop", "etc", "hadoop", "core-site.xml");
// 结果: /opt/hadoop/etc/hadoop/core-site.xml

// 处理末尾斜杠
String path1 = FileUtils.concatPath("/opt/", "hadoop/", "conf/");
// 结果: /opt/hadoop/conf

// 空路径过滤
String path2 = FileUtils.concatPath("/opt", "", "hadoop", null, "conf");
// 结果: /opt/hadoop/conf
```

### 2.5 CollectionUtils - 集合操作工具

#### 核心功能

##### 集合判空

```java
/**
 * 判断集合是否为空
 */
public static boolean isEmpty(Collection coll) {
    return coll == null || coll.isEmpty();
}

/**
 * 判断集合是否非空
 */
public static boolean isNotEmpty(Collection coll) {
    return !isEmpty(coll);
}
```

**使用场景**:
```java
List<HostInfo> hostList = getHostList();
if (CollectionUtils.isNotEmpty(hostList)) {
    // 处理主机列表
    for (HostInfo host : hostList) {
        // ...
    }
}
```

##### 字符串转Map

```java
/**
 * 将字符串转换为Map
 * @param str 字符串，格式: key1=value1,key2=value2
 * @param separator 分隔符
 * @param keyPrefix 键前缀
 * @return Map对象
 */
public static Map<String, String> stringToMap(String str, String separator, String keyPrefix) {
    Map<String, String> emptyMap = new HashMap<>(0);
    if (StringUtils.isEmpty(str) || StringUtils.isEmpty(separator)) {
        return emptyMap;
    }
    
    String[] strings = str.split(separator);
    int initialCapacity = (int) (strings.length / DEFAULT_LOAD_FACTOR) + 1;
    Map<String, String> map = new HashMap<>(initialCapacity);
    
    for (int i = 0; i < strings.length; i++) {
        String[] strArray = strings[i].split("=");
        if (strArray.length != 2) {
            return emptyMap;
        }
        if (StringUtils.isEmpty(keyPrefix)) {
            map.put(strArray[0], strArray[1]);
        } else {
            map.put(keyPrefix + strArray[0], strArray[1]);
        }
    }
    return map;
}
```

**使用场景**:
```java
// 解析配置字符串
String configStr = "host=192.168.1.1,port=8080,timeout=30";
Map<String, String> config = CollectionUtils.stringToMap(configStr, ",", "");

// 添加前缀
Map<String, String> config = CollectionUtils.stringToMap(configStr, ",", "app.");
// 结果: {app.host=192.168.1.1, app.port=8080, app.timeout=30}
```

##### 集合相等性判断

```java
/**
 * 判断两个集合是否包含相同元素（考虑元素出现次数）
 */
public static boolean equalLists(Collection<?> a, Collection<?> b) {
    if (a == null && b == null) {
        return true;
    }
    if (a == null || b == null) {
        return false;
    }
    return isEqualCollection(a, b);
}

public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {
    if (a.size() != b.size()) {
        return false;
    }
    final CardinalityHelper<Object> helper = new CardinalityHelper<>(a, b);
    if (helper.cardinalityA.size() != helper.cardinalityB.size()) {
        return false;
    }
    for (final Object obj : helper.cardinalityA.keySet()) {
        if (helper.freqA(obj) != helper.freqB(obj)) {
            return false;
        }
    }
    return true;
}
```

**使用场景**:
```java
List<String> roles1 = Arrays.asList("NameNode", "DataNode", "DataNode");
List<String> roles2 = Arrays.asList("DataNode", "NameNode", "DataNode");
boolean equal = CollectionUtils.equalLists(roles1, roles2);  // true

List<String> roles3 = Arrays.asList("NameNode", "DataNode");
boolean equal2 = CollectionUtils.equalLists(roles1, roles3);  // false
```

##### 对象列表转Map列表

```java
/**
 * 将对象列表转换为Map列表，并排除指定属性
 * @param originList 原始对象列表
 * @param exclusionSet 要排除的属性集合
 * @return Map列表
 */
public static <T extends Object> List<Map<String, Object>> getListByExclusion(
        List<T> originList,
        Set<String> exclusionSet) {
    List<Map<String, Object>> instanceList = new ArrayList<>();
    if (exclusionSet == null) {
        exclusionSet = new HashSet<>();
    }
    if (originList == null) {
        return instanceList;
    }
    
    Map<String, Object> instanceMap;
    for (T instance : originList) {
        Map<String, Object> dataMap = new BeanMap(instance);
        instanceMap = new LinkedHashMap<>(16, 0.75f, true);
        for (Map.Entry<String, Object> entry : dataMap.entrySet()) {
            if (exclusionSet.contains(entry.getKey())) {
                continue;
            }
            instanceMap.put(entry.getKey(), entry.getValue());
        }
        instanceList.add(instanceMap);
    }
    return instanceList;
}
```

**使用场景**:
```java
// 获取用户列表，排除敏感字段
List<User> users = userService.list();
Set<String> exclusions = new HashSet<>(Arrays.asList("password", "salt"));
List<Map<String, Object>> userMaps = CollectionUtils.getListByExclusion(users, exclusions);

// 返回给前端，不包含密码字段
return Result.success(userMaps);
```

### 2.6 PlaceholderUtils - 占位符替换工具

#### 核心功能

##### 占位符替换

```java
/**
 * 替换字符串中的占位符
 * @param value 原始字符串
 * @param paramsMap 参数映射
 * @param regex 占位符正则表达式
 * @return 替换后的字符串
 */
public static String replacePlaceholders(String value,
                                        Map<String, String> paramsMap, 
                                        String regex) {
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(value);
    
    // 自旋进行最小匹配，直到无法匹配
    while (matcher.find()) {
        String group = matcher.group();
        if (paramsMap.containsKey(group)) {
            value = value.replace(group, paramsMap.get(group));
        }
    }
    return value;
}
```

**使用场景**:
```java
// 配置文件模板替换
String template = "hdfs://\${namenode.host}:\${namenode.port}/data";
Map<String, String> params = new HashMap<>();
params.put("${namenode.host}", "node01");
params.put("${namenode.port}", "9000");

String regex = "\\$\\{(.*?)\\}";
String result = PlaceholderUtils.replacePlaceholders(template, params, regex);
// 结果: hdfs://node01:9000/data

// API配置替换
String apiConfig = "{\"host\": \"${apiHost}\", \"port\": ${apiPort}}";
params.put("${apiHost}", "192.168.1.1");
params.put("${apiPort}", "8080");
String config = PlaceholderUtils.replacePlaceholders(apiConfig, params, regex);
```

##### 序列号生成

```java
/**
 * 生成序列号列表
 * @param pre 起始序号
 * @param last 结束序号
 * @return 序列号列表
 */
public static List<String> getNewEquipmentNoList(String pre, String last) {
    int length = pre.length();
    ArrayList<String> list = new ArrayList<>();
    Integer start = Integer.parseInt(pre);
    Integer end = Integer.parseInt(last);
    int next = start;
    list.add(pre);
    while (next < end) {
        next = next + 1;
        String nextStr = String.format("%0" + length + "d", next);
        list.add(nextStr);
    }
    return list;
}
```

**使用场景**:
```java
// 生成主机名序列
List<String> hostnames = PlaceholderUtils.getNewEquipmentNoList("001", "010");
// 结果: [001, 002, 003, 004, 005, 006, 007, 008, 009, 010]

// 批量创建配置文件
for (String no : hostnames) {
    String hostname = "node" + no;
    // 创建配置...
}
```

## 三、其他工具类简介

### 3.1 PropertyUtils - 配置文件读取

**功能**: 读取 application.properties 配置文件

**核心方法**:
```java
public static String getString(String key)
public static String getString(String key, String defaultValue)
public static Integer getInt(String key)
public static Boolean getBoolean(String key)
```

**使用场景**:
```java
String installPath = PropertyUtils.getString("install.path");
Integer timeout = PropertyUtils.getInt("command.timeout", 60);
```

### 3.2 HostUtils - 主机信息工具

**功能**: 获取主机相关信息

**使用场景**:
```java
String hostname = HostUtils.getHostname();
String ip = HostUtils.getIpAddress();
```

### 3.3 EncryptionUtils - 加密工具

**功能**: 提供密码加密和解密功能

**使用场景**:
```java
String encrypted = EncryptionUtils.encrypt(password);
String decrypted = EncryptionUtils.decrypt(encrypted);
```

### 3.4 PromInfoUtils - Prometheus工具

**功能**: 解析 Prometheus 查询结果

**使用场景**:
```java
PromResponceInfo response = prometheusService.query(query);
List<Map<String, Object>> metrics = PromInfoUtils.parseMetrics(response);
```

### 3.5 OlapUtils - OLAP工具

**功能**: StarRocks/Doris 等 OLAP 数据库操作

**使用场景**:
```java
OlapUtils.executeSql(host, port, sql);
OlapUtils.createUser(host, port, username, password);
```

## 四、使用最佳实践

### 4.1 异常处理

```java
// ✅ 推荐：捕获具体异常
try {
    ExecResult result = ShellUtils.exceShell(command);
    if (!result.getExecResult()) {
        logger.error("命令执行失败: {}", result.getExecErrOut());
    }
} catch (Exception e) {
    logger.error("执行命令异常", e);
}

// ❌ 不推荐：忽略异常
ShellUtils.exceShell(command);
```

### 4.2 资源管理

```java
// ✅ 推荐：使用try-with-resources
try (FileInputStream fis = new FileInputStream(file)) {
    // 处理文件
}

// ❌ 不推荐：手动关闭（容易遗漏）
FileInputStream fis = null;
try {
    fis = new FileInputStream(file);
    // 处理文件
} finally {
    if (fis != null) {
        fis.close();
    }
}
```

### 4.3 空值检查

```java
// ✅ 推荐：使用工具类判空
if (CollectionUtils.isEmpty(list)) {
    return Result.successEmptyCount();
}

// ❌ 不推荐：手动判断
if (list == null || list.size() == 0) {
    return Result.successEmptyCount();
}
```

### 4.4 链式调用

```java
// ✅ 推荐：链式调用，代码简洁
return Result.success()
    .put("list", list)
    .put("total", total)
    .put("page", page);

// ❌ 不推荐：多行调用
Result result = Result.success();
result.put("list", list);
result.put("total", total);
result.put("page", page);
return result;
```

## 五、性能优化建议

### 5.1 文件操作

```java
// ✅ 推荐：分块读取大文件
byte[] buffer = new byte[8192];
while ((length = fis.read(buffer)) != -1) {
    md5.update(buffer, 0, length);
}

// ❌ 不推荐：一次性读取大文件
byte[] allBytes = Files.readAllBytes(file.toPath());
```

### 5.2 集合初始化

```java
// ✅ 推荐：指定初始容量
int initialCapacity = (int) (size / 0.75f) + 1;
Map<String, String> map = new HashMap<>(initialCapacity);

// ❌ 不推荐：使用默认容量，可能频繁扩容
Map<String, String> map = new HashMap<>();
```

### 5.3 命令执行

```java
// ✅ 推荐：设置超时，避免长时间阻塞
ExecResult result = ShellUtils.execWithStatus(workPath, command, 60);

// ❌ 不推荐：无限等待
Process process = Runtime.getRuntime().exec(command);
process.waitFor();  // 可能永久阻塞
```

## 六、总结

### 核心价值

1. **提高开发效率**: 封装常用操作，减少重复代码
2. **统一编程风格**: 规范化的 API 设计
3. **降低出错概率**: 经过测试的工具方法
4. **便于维护**: 集中管理通用逻辑

### 设计亮点

1. **Result统一响应**: 规范 API 返回格式
2. **Shell命令封装**: 简化系统命令调用
3. **文件大文件支持**: MD5 分块计算
4. **集合操作丰富**: 常用集合操作封装
5. **占位符替换**: 灵活的模板替换

### 使用建议

1. 优先使用工具类方法，避免重复造轮子
2. 注意异常处理，不要吞掉异常
3. 合理使用缓存，避免重复计算
4. 关注性能，选择合适的算法
5. 遵循最佳实践，编写优雅代码

---

**文档版本**: v1.0  
**最后更新**: 2025-11-15  
**分析人员**: DataSophon 源码分析团队
