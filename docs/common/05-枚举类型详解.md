# DataSophon Common 模块 - 枚举类型详解

## 一、模块概述

**模块路径**: `datasophon-common/src/main/java/com/datasophon/common/enums/`

**功能定位**: 定义系统中使用的枚举类型，提供类型安全的常量定义

**枚举列表** (9个):
1. **CommandType** - 命令类型枚举
2. **ClusterCommandType** - 集群命令类型枚举  
3. **InstallState** - 安装状态枚举
4. **ServiceExecuteState** - 服务执行状态枚举
5. **OperateType** - 操作类型枚举
6. **ServiceRoleType** - 服务角色类型枚举
7. **ConfigFileType** - 配置文件类型枚举
8. **RunnerType** - 运行器类型枚举
9. **ReplyType** - 响应类型枚举

## 二、核心枚举详解

### 2.1 CommandType - 命令类型枚举

#### 枚举定义

```java
public enum CommandType {
    // 命令类型：1-安装服务 2-启动服务 3-停止服务 4-重启服务 5-更新配置后启动 6-更新配置后重启
    INSTALL_SERVICE(1, "INSTALL", "安装"),
    START_SERVICE(2, "START", "启动"),
    STOP_SERVICE(3, "STOP", "停止"),
    RESTART_SERVICE(4, "RESTART", "重启"),
    START_WITH_CONFIG(5, "START_WITH_CONFIG", ""),
    RESTART_WITH_CONFIG(6, "RESTART_WITH_CONFIG", "znDesc");
    
    private int value;
    private String desc;
    private String cnDesc;
    
    CommandType(int value, String desc, String cnDesc) {
        this.value = value;
        this.desc = desc;
        this.cnDesc = cnDesc;
    }
    
    @JsonValue
    public String getDesc() {
        return desc;
    }
    
    public String getCommandName(String language) {
        if (Constants.CN.equals(language)) {
            return this.cnDesc;
        } else {
            return this.desc;
        }
    }
    
    @Override
    public String toString() {
        return this.desc;
    }
}
```

#### 枚举值详解

| 枚举值 | 值 | 英文描述 | 中文描述 | 用途说明 |
|--------|---|---------|---------|---------|
| INSTALL_SERVICE | 1 | INSTALL | 安装 | 安装服务到目标节点 |
| START_SERVICE | 2 | START | 启动 | 启动已安装的服务 |
| STOP_SERVICE | 3 | STOP | 停止 | 停止运行中的服务 |
| RESTART_SERVICE | 4 | RESTART | 重启 | 重启服务（停止后启动）|
| START_WITH_CONFIG | 5 | START_WITH_CONFIG | - | 更新配置后启动服务 |
| RESTART_WITH_CONFIG | 6 | RESTART_WITH_CONFIG | - | 更新配置后重启服务 |

#### 使用场景

```java
// 创建服务安装命令
ExecuteServiceRoleCommand command = new ExecuteServiceRoleCommand();
command.setCommandType(CommandType.INSTALL_SERVICE);
command.setServiceName("HDFS");
command.setServiceRoleName("NameNode");

// 根据语言获取命令名称
String commandName = CommandType.START_SERVICE.getCommandName("chinese");
// 结果: "启动"

// Switch语句使用
switch (commandType) {
    case INSTALL_SERVICE:
        installService(serviceRole);
        break;
    case START_SERVICE:
        startService(serviceRole);
        break;
    case STOP_SERVICE:
        stopService(serviceRole);
        break;
    case RESTART_SERVICE:
        restartService(serviceRole);
        break;
}

// JSON序列化（使用@JsonValue注解）
{
  "commandType": "START",  // 序列化为desc字段
  "serviceName": "HDFS"
}
```

#### 设计特点

1. **多语言支持**: 同时提供英文和中文描述
2. **数值编码**: 便于数据库存储和比较
3. **JSON友好**: 使用 @JsonValue 控制序列化格式
4. **类型安全**: 编译期检查，避免魔法值

### 2.2 InstallState - 安装状态枚举

#### 枚举定义

```java
public enum InstallState {
    // 安装状态：1-正在安装 2-安装成功 3-安装失败
    RUNNING(1, "正在安装"),
    SUCCESS(2, "安装成功"),
    FAILED(3, "安装失败");
    
    private int value;
    private String desc;
    
    InstallState(int value, String desc) {
        this.value = value;
        this.desc = desc;
    }
    
    @JsonValue
    public String getDesc() {
        return desc;
    }
}
```

#### 状态流转图

```
┌─────────────┐
│  待安装     │
└──────┬──────┘
       │
       ↓
┌─────────────┐
│  RUNNING    │ ─────┐
│  正在安装   │      │
└──────┬──────┘      │
       │             │ 超时/异常
       │             │
       ├─成功────────┼────→ ┌─────────────┐
       │             │      │  SUCCESS    │
       │             │      │  安装成功   │
       │             │      └─────────────┘
       │             │
       └─失败────────┼────→ ┌─────────────┐
                     │      │  FAILED     │
                     └────→ │  安装失败   │
                            └─────────────┘
```

#### 使用场景

```java
// 记录安装状态
public void installService(ServiceRole serviceRole) {
    // 设置为安装中
    serviceRole.setInstallState(InstallState.RUNNING);
    serviceRoleMapper.updateById(serviceRole);
    
    try {
        // 执行安装逻辑
        executeInstall(serviceRole);
        
        // 设置为安装成功
        serviceRole.setInstallState(InstallState.SUCCESS);
        serviceRoleMapper.updateById(serviceRole);
        
        logger.info("服务安装成功: {}", serviceRole.getServiceRoleName());
    } catch (Exception e) {
        // 设置为安装失败
        serviceRole.setInstallState(InstallState.FAILED);
        serviceRoleMapper.updateById(serviceRole);
        
        logger.error("服务安装失败: {}", serviceRole.getServiceRoleName(), e);
    }
}

// 查询安装中的服务
List<ServiceRole> installingRoles = serviceRoleMapper.selectList(
    new QueryWrapper<ServiceRole>()
        .eq("install_state", InstallState.RUNNING.getValue())
);

// 前端展示
if (serviceRole.getInstallState() == InstallState.SUCCESS) {
    showSuccess("安装成功");
} else if (serviceRole.getInstallState() == InstallState.FAILED) {
    showError("安装失败，请查看日志");
} else {
    showLoading("正在安装中...");
}
```

### 2.3 ServiceExecuteState - 服务执行状态枚举

#### 枚举定义

```java
public enum ServiceExecuteState {
    RUNNING,    // 运行中
    ERROR,      // 错误
    SUCCESS;    // 成功
}
```

**特点**: 简化枚举，仅定义枚举值，无额外字段

#### 使用场景

```java
// 记录命令执行状态
public class CommandResult {
    private ServiceExecuteState state;
    private String message;
}

// 异步任务状态跟踪
public void executeServiceCommand(Command command) {
    command.setState(ServiceExecuteState.RUNNING);
    commandMapper.updateById(command);
    
    CompletableFuture.runAsync(() -> {
        try {
            // 执行命令
            executeCommand(command);
            
            command.setState(ServiceExecuteState.SUCCESS);
            command.setMessage("执行成功");
        } catch (Exception e) {
            command.setState(ServiceExecuteState.ERROR);
            command.setMessage(e.getMessage());
        } finally {
            commandMapper.updateById(command);
        }
    });
}

// 查询失败的命令
List<Command> errorCommands = commandMapper.selectList(
    new QueryWrapper<Command>()
        .eq("state", ServiceExecuteState.ERROR.name())
);
```

### 2.4 ServiceRoleType - 服务角色类型枚举

#### 枚举定义

```java
public enum ServiceRoleType {
    MASTER(1, "master"),   // 主节点
    WORKER(2, "worker"),   // 工作节点
    CLIENT(3, "client"),   // 客户端
    SLAVE(4, "slave");     // 从节点
    
    private Integer code;
    private String name;
    
    ServiceRoleType(Integer code, String name) {
        this.code = code;
        this.name = name;
    }
    
    @JsonValue
    public String getName() {
        return name;
    }
}
```

#### 角色类型说明

| 角色类型 | 编码 | 说明 | 典型组件示例 |
|---------|------|------|-------------|
| MASTER | 1 | 主节点，协调和管理其他节点 | NameNode, ResourceManager, ZooKeeper |
| WORKER | 2 | 工作节点，执行具体任务 | DataNode, NodeManager |
| CLIENT | 3 | 客户端，提供命令行接口 | HDFS Client, YARN Client |
| SLAVE | 4 | 从节点，与主节点配合工作 | Secondary NameNode, Standby NameNode |

#### 使用场景

```java
// HDFS服务角色定义
public class HDFSService {
    // NameNode - MASTER角色
    ServiceRole nameNode = new ServiceRole();
    nameNode.setServiceRoleType(ServiceRoleType.MASTER);
    nameNode.setRoleName("NameNode");
    
    // DataNode - WORKER角色
    ServiceRole dataNode = new ServiceRole();
    dataNode.setServiceRoleType(ServiceRoleType.WORKER);
    dataNode.setRoleName("DataNode");
    
    // HDFS Client - CLIENT角色
    ServiceRole client = new ServiceRole();
    client.setServiceRoleType(ServiceRoleType.CLIENT);
    client.setRoleName("HDFSClient");
}

// 根据角色类型分配节点
public List<Host> allocateHosts(ServiceRole role) {
    if (role.getServiceRoleType() == ServiceRoleType.MASTER) {
        // Master角色通常部署在高可用节点
        return selectHighAvailabilityHosts(2);
    } else if (role.getServiceRoleType() == ServiceRoleType.WORKER) {
        // Worker角色可以部署在所有数据节点
        return selectAllDataNodes();
    } else if (role.getServiceRoleType() == ServiceRoleType.CLIENT) {
        // Client角色可以部署在边缘节点
        return selectEdgeNodes();
    }
    return Collections.emptyList();
}

// 检查角色依赖
public boolean checkDependency(ServiceRole role) {
    // Worker角色依赖Master角色先启动
    if (role.getServiceRoleType() == ServiceRoleType.WORKER) {
        return isMasterRunning();
    }
    return true;
}
```

### 2.5 OperateType - 操作类型枚举

#### 枚举定义

```java
public enum OperateType {
    START,      // 启动
    STOP,       // 停止
    RESTART;    // 重启
}
```

#### 使用场景

```java
// 服务操作接口
@PostMapping("/service/operate")
public Result operateService(@RequestParam Integer serviceId,
                             @RequestParam OperateType operateType) {
    switch (operateType) {
        case START:
            return serviceOperator.start(serviceId);
        case STOP:
            return serviceOperator.stop(serviceId);
        case RESTART:
            return serviceOperator.restart(serviceId);
        default:
            return Result.error("不支持的操作类型");
    }
}

// 批量操作
public void batchOperate(List<Integer> serviceIds, OperateType operateType) {
    for (Integer serviceId : serviceIds) {
        try {
            performOperate(serviceId, operateType);
            logger.info("服务{}{}成功", serviceId, operateType.name());
        } catch (Exception e) {
            logger.error("服务{}{}失败", serviceId, operateType.name(), e);
        }
    }
}
```

### 2.6 ConfigFileType - 配置文件类型枚举

#### 枚举定义

```java
public enum ConfigFileType {
    XML,          // XML配置文件
    PROPERTIES,   // Properties配置文件
    YAML,         // YAML配置文件
    CUSTOM;       // 自定义配置文件
}
```

#### 使用场景

```java
// 根据文件类型选择解析器
public Map<String, String> parseConfigFile(File file, ConfigFileType type) {
    switch (type) {
        case XML:
            return XmlConfigParser.parse(file);
        case PROPERTIES:
            return PropertiesConfigParser.parse(file);
        case YAML:
            return YamlConfigParser.parse(file);
        case CUSTOM:
            return CustomConfigParser.parse(file);
        default:
            throw new IllegalArgumentException("不支持的配置文件类型");
    }
}

// 服务配置定义
public class ServiceConfig {
    private String name;              // 配置项名称
    private String value;             // 配置值
    private ConfigFileType fileType;  // 文件类型
    
    public String getFileName() {
        switch (fileType) {
            case XML:
                return name + ".xml";
            case PROPERTIES:
                return name + ".properties";
            case YAML:
                return name + ".yaml";
            default:
                return name;
        }
    }
}
```

### 2.7 RunnerType - 运行器类型枚举

#### 枚举定义

```java
public enum RunnerType {
    SCRIPT,     // 脚本运行器
    COMMAND,    // 命令运行器
    JAVA;       // Java运行器
}
```

#### 使用场景

```java
// 根据运行器类型执行任务
public void executeTask(Task task) {
    switch (task.getRunnerType()) {
        case SCRIPT:
            // 执行Shell脚本
            ShellUtils.exceShell(task.getScript());
            break;
        case COMMAND:
            // 执行系统命令
            Runtime.getRuntime().exec(task.getCommand());
            break;
        case JAVA:
            // 执行Java类
            executeJavaClass(task.getClassName());
            break;
    }
}

// 服务角色运行器配置
public class ServiceRoleRunner {
    private RunnerType type;          // 运行器类型
    private String program;           // 程序路径
    private List<String> args;        // 参数列表
    
    public void run() {
        if (type == RunnerType.SCRIPT) {
            ShellUtils.exceShell(program + " " + String.join(" ", args));
        } else if (type == RunnerType.COMMAND) {
            List<String> command = new ArrayList<>();
            command.add(program);
            command.addAll(args);
            ShellUtils.exec(command);
        }
    }
}
```

### 2.8 ReplyType - 响应类型枚举

#### 枚举定义

```java
public enum ReplyType {
    SUCCESS,    // 成功响应
    FAILURE;    // 失败响应
}
```

#### 使用场景

```java
// Akka消息响应
public class AkkaReply {
    private ReplyType type;
    private String message;
    
    public static AkkaReply success(String message) {
        AkkaReply reply = new AkkaReply();
        reply.setType(ReplyType.SUCCESS);
        reply.setMessage(message);
        return reply;
    }
    
    public static AkkaReply failure(String message) {
        AkkaReply reply = new AkkaReply();
        reply.setType(ReplyType.FAILURE);
        reply.setMessage(message);
        return reply;
    }
}

// 消息处理
public void handleReply(AkkaReply reply) {
    if (reply.getType() == ReplyType.SUCCESS) {
        logger.info("操作成功: {}", reply.getMessage());
        updateStatus(Status.SUCCESS);
    } else {
        logger.error("操作失败: {}", reply.getMessage());
        updateStatus(Status.FAILED);
        sendAlert(reply.getMessage());
    }
}
```

### 2.9 ClusterCommandType - 集群命令类型枚举

#### 枚举定义

```java
public enum ClusterCommandType {
    CREATE_CLUSTER,       // 创建集群
    DELETE_CLUSTER,       // 删除集群
    START_CLUSTER,        // 启动集群
    STOP_CLUSTER,         // 停止集群
    RESTART_CLUSTER;      // 重启集群
}
```

#### 使用场景

```java
// 集群级别操作
public Result executeClusterCommand(Integer clusterId, ClusterCommandType commandType) {
    ClusterInfo cluster = clusterMapper.selectById(clusterId);
    
    switch (commandType) {
        case CREATE_CLUSTER:
            return createCluster(cluster);
        case DELETE_CLUSTER:
            return deleteCluster(cluster);
        case START_CLUSTER:
            return startAllServices(cluster);
        case STOP_CLUSTER:
            return stopAllServices(cluster);
        case RESTART_CLUSTER:
            return restartAllServices(cluster);
        default:
            return Result.error("不支持的集群命令");
    }
}
```

## 三、枚举设计模式

### 3.1 枚举单例模式

```java
// 枚举天然单例，线程安全
public enum ConfigManager {
    INSTANCE;
    
    private Map<String, String> config = new HashMap<>();
    
    public void put(String key, String value) {
        config.put(key, value);
    }
    
    public String get(String key) {
        return config.get(key);
    }
}

// 使用
ConfigManager.INSTANCE.put("key", "value");
String value = ConfigManager.INSTANCE.get("key");
```

### 3.2 策略模式

```java
public enum OperationStrategy {
    ADD {
        @Override
        public int execute(int a, int b) {
            return a + b;
        }
    },
    SUBTRACT {
        @Override
        public int execute(int a, int b) {
            return a - b;
        }
    },
    MULTIPLY {
        @Override
        public int execute(int a, int b) {
            return a * b;
        }
    };
    
    public abstract int execute(int a, int b);
}

// 使用
int result = OperationStrategy.ADD.execute(5, 3);  // 8
```

### 3.3 状态机模式

```java
public enum ServiceState {
    STOPPED {
        @Override
        public ServiceState start() {
            return STARTING;
        }
    },
    STARTING {
        @Override
        public ServiceState complete() {
            return RUNNING;
        }
        @Override
        public ServiceState error() {
            return STOPPED;
        }
    },
    RUNNING {
        @Override
        public ServiceState stop() {
            return STOPPING;
        }
    },
    STOPPING {
        @Override
        public ServiceState complete() {
            return STOPPED;
        }
    };
    
    public ServiceState start() {
        throw new IllegalStateException("无法从" + this + "状态启动");
    }
    
    public ServiceState stop() {
        throw new IllegalStateException("无法从" + this + "状态停止");
    }
    
    public ServiceState complete() {
        throw new IllegalStateException("无法完成" + this + "状态");
    }
    
    public ServiceState error() {
        throw new IllegalStateException(this + "状态发生错误");
    }
}
```

## 四、最佳实践

### 4.1 枚举命名规范

```java
// ✅ 推荐：清晰的枚举名称
public enum ServiceState {
    RUNNING,
    STOPPED,
    STARTING
}

// ❌ 不推荐：缩写或不明确
public enum SS {
    R,
    S,
    ST
}
```

### 4.2 使用枚举替代常量

```java
// ✅ 推荐：使用枚举
if (command.getType() == CommandType.START_SERVICE) {
    // 类型安全，编译期检查
}

// ❌ 不推荐：使用魔法值
if (command.getType() == 2) {
    // 不安全，容易出错
}
```

### 4.3 枚举方法扩展

```java
public enum CommandType {
    INSTALL_SERVICE(1, "INSTALL", "安装"),
    START_SERVICE(2, "START", "启动");
    
    // 添加实用方法
    public static CommandType fromValue(int value) {
        for (CommandType type : values()) {
            if (type.getValue() == value) {
                return type;
            }
        }
        throw new IllegalArgumentException("未知的命令类型: " + value);
    }
    
    public boolean isInstall() {
        return this == INSTALL_SERVICE;
    }
    
    public boolean isOperate() {
        return this == START_SERVICE || this == STOP_SERVICE || this == RESTART_SERVICE;
    }
}
```

### 4.4 枚举与数据库

```java
// MyBatis TypeHandler
public class CommandTypeHandler extends BaseTypeHandler<CommandType> {
    
    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, CommandType parameter, JdbcType jdbcType) 
            throws SQLException {
        ps.setInt(i, parameter.getValue());
    }
    
    @Override
    public CommandType getNullableResult(ResultSet rs, String columnName) 
            throws SQLException {
        int value = rs.getInt(columnName);
        return CommandType.fromValue(value);
    }
    
    // 其他方法实现...
}

// 使用
@TableField(typeHandler = CommandTypeHandler.class)
private CommandType commandType;
```

### 4.5 JSON序列化

```java
// 使用 @JsonValue 控制序列化格式
public enum CommandType {
    START_SERVICE(2, "START", "启动");
    
    @JsonValue  // 序列化时使用desc字段
    public String getDesc() {
        return desc;
    }
}

// JSON输出
{
  "commandType": "START"  // 而不是 "START_SERVICE"
}
```

## 五、枚举对比分析

### 5.1 枚举 vs 常量类

| 特性 | 枚举 | 常量类 |
|------|------|--------|
| 类型安全 | ✅ 强类型 | ❌ 基本类型 |
| 编译期检查 | ✅ 支持 | ❌ 不支持 |
| Switch完整性 | ✅ 编译器提示 | ❌ 无提示 |
| 方法扩展 | ✅ 支持 | ❌ 不支持 |
| 单例保证 | ✅ 天然单例 | ⚠️ 需要手动实现 |
| 序列化 | ✅ 自动支持 | ⚠️ 需要手动处理 |

### 5.2 使用建议

**适合使用枚举的场景**:
- 固定数量的常量集合
- 需要类型安全的场景
- 需要为常量添加行为
- 状态机实现
- 策略模式实现

**不适合使用枚举的场景**:
- 常量数量可能动态变化
- 需要运行时添加新值
- 超大量的常量（影响启动性能）

## 六、总结

### 核心价值

1. **类型安全**: 编译期类型检查，避免魔法值
2. **可读性强**: 语义明确，代码自文档化
3. **维护性好**: 集中管理，便于修改
4. **功能丰富**: 支持方法、字段、抽象方法

### 设计亮点

1. **多语言支持**: CommandType 支持中英文切换
2. **数值编码**: 便于数据库存储和传输
3. **JSON友好**: @JsonValue 控制序列化格式
4. **简洁设计**: 简单枚举仅定义值，不增加复杂度

### 改进建议

1. 为所有枚举添加 fromValue() 方法
2. 统一中英文描述字段命名
3. 添加枚举值验证方法
4. 完善 JavaDoc 文档
5. 考虑使用 EnumSet 优化性能

---

**文档版本**: v1.0  
**最后更新**: 2025-11-15  
**分析人员**: DataSophon 源码分析团队
