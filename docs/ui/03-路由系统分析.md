# DataSophon UI 模块 - 路由系统分析

## 一、路由系统概述

DataSophon UI 使用 Vue Router 3.x 实现前端路由管理，采用**动态路由 + 权限控制 + 多模式切换**的架构设计，支持静态路由和动态路由两种模式。

### 核心特性

- ✅ **动态路由**: 支持根据后端配置动态加载路由
- ✅ **权限控制**: 基于角色和权限的路由访问控制
- ✅ **路由守卫**: 登录守卫、权限守卫、进度条守卫
- ✅ **懒加载**: 所有页面组件按需加载
- ✅ **多模式**: 支持集群模式和全局模式切换
- ✅ **国际化**: 路由标题支持 i18n

## 二、路由文件结构

```
src/router/
├── index.js                 # 路由入口、初始化
├── config.js                # 静态路由配置（全局模式）
├── config-cluster.js        # 静态路由配置（集群模式）
├── guards.js                # 路由守卫配置
├── i18n.js                  # 路由国际化
└── async/
    ├── config.async.js      # 异步路由基础配置
    └── router.map.js        # 路由组件映射表
```

## 三、核心文件详细分析

### 3.1 index.js - 路由入口

#### 文件路径
`src/router/index.js`

#### 主要功能

##### 1. 登录白名单配置

```javascript
const loginIgnore = {
  names: ['404', '403'],      // 根据路由名称匹配
  paths: ['/login'],          // 根据路由路径匹配
  
  /**
   * 判断路由是否在白名单中
   * @param route vue-router 的 route 对象
   * @returns {boolean}
   */
  includes(route) {
    return this.names.includes(route.name) || this.paths.includes(route.path)
  }
}
```

**作用**: 
- 定义不需要登录验证的路由
- 登录页、404、403 等错误页面无需验证
- 在路由守卫中使用，提高性能

##### 2. 路由初始化函数

```javascript
/**
 * 初始化路由实例
 * @param isAsync 是否异步路由模式
 * @returns {VueRouter}
 */
function initRouter(isAsync) {
  // 根据模式选择不同的路由配置
  const options = isAsync 
    ? require('./config-cluster').default   // 集群模式
    : require('./config').default           // 全局模式
  
  // 格式化路由
  formatRoutes(options.routes)
  
  // 创建并返回路由实例
  return new Router(options)
}
```

**设计亮点**:
- 支持两种路由模式动态切换
- 按需加载配置文件
- 统一格式化路由配置

### 3.2 config.js - 静态路由配置

#### 文件路径
`src/router/config.js`

#### 路由结构

```javascript
const options = {
  routes: [
    // 1. 登录页
    {
      path: '/login',
      name: '登录页',
      component: () => import('@/pages/login')
    },
    
    // 2. 错误页面
    {
      path: '*',
      name: '404',
      component: () => import('@/pages/exception/404')
    },
    {
      path: '/403',
      name: '403',
      component: () => import('@/pages/exception/403')
    },
    
    // 3. 主应用路由
    {
      path: '/',
      name: '首页',
      component: TabsView,           // 标签页布局
      redirect: '/login',            // 默认重定向到登录页
      children: [...]                // 子路由
    }
  ]
}
```

#### 核心业务路由详解

##### 1. 总览页面

```javascript
{
  path: 'overview',
  name: '总览',
  meta: {
    notAlive: true,              // 不缓存页面
    icon: 'over-view',           // 图标
    isCluster: 'isCluster'       // 集群模式标识
  },
  component: () => import('@/pages/overview/index'),
  children: []
}
```

**特点**:
- `notAlive: true`: 每次进入都重新加载，确保数据最新
- `isCluster`: 标识该路由仅在集群模式下显示

##### 2. 服务管理

```javascript
{
  path: 'service-manage',
  name: '服务管理',
  meta: {
    icon: 'service-manage',
    isCluster: 'isCluster'
  },
  component: PageView,           // 页面容器组件
  children: [{
    meta: {
      notAlive: true,
      params: {
        serviceId: ''            // 动态参数
      }
    },
    path: 'service-list/:serviceId',  // 动态路由参数
    name: '服务管理',
    component: () => import('@/pages/serviceManage/index')
  }]
}
```

**设计说明**:
- 使用动态路由参数 `:serviceId`
- 支持不同服务的页面切换
- 每次切换服务都重新加载数据

##### 3. 集群管理

```javascript
{
  path: 'colony-manage',
  name: '集群管理',
  meta: {
    icon: 'cluster',
    isCluster: ''                // 全局模式
  },
  component: PageView,
  children: [
    {
      path: 'colony-list',
      meta: { notAlive: true },
      name: '集群管理',
      component: () => import('@/pages/colonyManage/list')
    },
    {
      path: 'colony-parcel',
      name: '存储库管理',
      component: () => import('@/pages/colonyManage/parcel')
    },
    {
      path: 'colony-frame',
      name: '集群框架',
      component: () => import('@/pages/colonyManage/frame')
    }
  ]
}
```

**层级结构**:
- 一级路由: 集群管理
- 二级路由: 集群列表、存储库管理、集群框架

##### 4. 主机管理

```javascript
{
  path: 'host-manage',
  name: '主机管理',
  meta: {
    icon: 'host',
    isCluster: 'isCluster'
  },
  component: () => import('@/pages/hostManage/index'),
  children: []
}
```

##### 5. 告警管理

```javascript
{
  path: 'alarm-manage',
  name: '告警管理',
  meta: {
    icon: 'gaojing',
    isCluster: 'isCluster'
  },
  component: PageView,
  children: [
    {
      path: 'group',
      meta: { notAlive: false },  // 缓存页面
      name: '告警组管理',
      label: '告警组管理',
      component: () => import('@/pages/alarmManage/group')
    },
    {
      path: 'metric',
      meta: { notAlive: true },   // 不缓存
      name: '告警指标管理',
      label: '告警指标管理',
      component: () => import('@/pages/alarmManage/metric')
    }
  ]
}
```

##### 6. 安全中心

```javascript
{
  path: 'security-center',
  name: '用户管理',
  meta: {
    icon: 'safety-certificate',
    isCluster: ''
  },
  component: PageView,
  children: [{
    path: 'user',
    name: '用户管理',
    component: () => import('@/pages/securityCenter/user')
  }]
}
```

##### 7. 系统管理

```javascript
{
  path: 'system-center',
  name: '系统管理',
  label: '系统管理',
  meta: {
    icon: 'system-icon',
    isCluster: 'isCluster'
  },
  component: PageView,
  children: [
    {
      path: 'user',
      name: '租户管理',
      label: '租户管理',
      component: () => import('@/pages/systemCenter/user')
    },
    {
      path: 'frame',
      name: '机架管理',
      label: '机架管理',
      component: () => import('@/pages/systemCenter/frame/index')
    },
    {
      path: 'tag',
      name: '标签管理',
      label: '标签管理',
      component: () => import('@/pages/systemCenter/tag/index')
    }
  ]
}
```

#### 路由元信息 (meta) 字段说明

| 字段 | 类型 | 说明 |
|------|------|------|
| icon | String | 菜单图标 |
| notAlive | Boolean | 是否缓存页面 (true=不缓存) |
| isCluster | String | 'isCluster'=集群模式显示, ''=全局模式显示 |
| params | Object | 路由参数 |
| authority | String/Object | 权限配置 |
| invisible | Boolean | 是否在菜单中隐藏 |

### 3.3 guards.js - 路由守卫

#### 文件路径
`src/router/guards.js`

#### 守卫类型

##### 1. 进度条守卫 (progressStart)

```javascript
/**
 * 进度条开始
 * @param to 目标路由
 * @param from 来源路由
 * @param next 继续函数
 */
const progressStart = (to, from, next) => {
  // 开启进度条
  if (!NProgress.isStarted()) {
    NProgress.start()
  }
  next()
}
```

**作用**: 
- 路由跳转时显示顶部进度条
- 提升用户体验
- 基于 NProgress 库

##### 2. 登录守卫 (loginGuard)

```javascript
/**
 * 登录守卫
 * @param to 目标路由
 * @param from 来源路由
 * @param next 继续函数
 * @param options 配置选项 {message, store}
 */
const loginGuard = (to, from, next, options) => {
  const {message} = options
  
  // 检查是否在白名单中，以及是否已登录
  if (!loginIgnore.includes(to) && !checkAuthorization()) {
    message.warning('登录已失效，请重新登录')
    next({path: '/login'})
  } else {
    next()
  }
}
```

**功能**:
- 检查用户是否已登录
- 白名单路由直接放行
- 未登录用户重定向到登录页

**checkAuthorization 实现**:
```javascript
// src/utils/request.js
export function checkAuthorization() {
  const token = localStorage.getItem('token')
  return !!token  // 检查 token 是否存在
}
```

##### 3. 权限守卫 (authorityGuard)

```javascript
/**
 * 权限守卫
 * @param to 目标路由
 * @param from 来源路由
 * @param next 继续函数
 * @param options 配置选项 {store, message}
 */
const authorityGuard = (to, from, next, options) => {
  const {store, message} = options
  
  // 获取用户权限和角色
  const permissions = store.getters['account/permissions']
  const roles = store.getters['account/roles']
  
  // 检查是否有权限访问该路由
  if (!hasAuthority(to, permissions, roles)) {
    message.warning(`对不起，您无权访问页面: ${to.fullPath}，请联系管理员`)
    next({path: '/403'})
  } else {
    next()
  }
}
```

**权限检查逻辑**:
```javascript
// src/utils/authority-utils.js
export function hasAuthority(route, permissions, roles) {
  const authority = route.meta.authority
  
  // 没有配置权限，默认允许
  if (!authority) {
    return true
  }
  
  // 通配符，所有人都可以访问
  if (authority === '*') {
    return true
  }
  
  // 检查权限
  if (authority.permission) {
    return permissions.includes(authority.permission)
  }
  
  // 检查角色
  if (authority.role) {
    return roles.some(role => authority.role.includes(role))
  }
  
  return false
}
```

##### 4. 重定向守卫 (redirectGuard)

```javascript
/**
 * 混合导航模式下一级菜单跳转重定向
 * @param to 目标路由
 * @param from 来源路由
 * @param next 继续函数
 * @param options 配置选项 {store}
 */
const redirectGuard = (to, from, next, options) => {
  const clusterId = localStorage.getItem('clusterId')
  const isCluster = localStorage.getItem('isCluster')
  const {store} = options
  
  // 获取第一个子路由
  const getFirstChild = (routes) => {
    const route = routes[0]
    if (!route.children || route.children.length === 0) {
      return route
    }
    return getFirstChild(route.children)
  }
  
  // 混合布局模式下的重定向逻辑
  if (store.state.setting.layout === 'mix') {
    const firstMenu = store.getters['setting/firstMenu']
    if (firstMenu.find(item => item.fullPath === to.fullPath)) {
      store.commit('setting/setActivatedFirst', to.fullPath)
      const subMenu = store.getters['setting/subMenu']
      if (subMenu.length > 0) {
        const redirect = getFirstChild(subMenu)
        return next({path: redirect.fullPath})
      }
    }
  }
  next()
}
```

**功能**: 
- 处理混合布局模式
- 一级菜单自动重定向到第一个子菜单
- 支持集群切换

##### 5. 进度条结束守卫 (progressDone)

```javascript
/**
 * 进度条结束
 */
const progressDone = () => {
  NProgress.done()
}
```

#### 守卫配置导出

```javascript
export default {
  beforeEach: [
    progressStart,      // 1. 开启进度条
    loginGuard,         // 2. 检查登录状态
    authorityGuard,     // 3. 检查访问权限
    redirectGuard       // 4. 处理重定向
  ],
  afterEach: [
    progressDone        // 5. 关闭进度条
  ]
}
```

**执行顺序**: 
1. 进度条开始
2. 登录验证
3. 权限验证
4. 重定向处理
5. 进度条结束

### 3.4 routerUtil.js - 路由工具类

#### 文件路径
`src/utils/routerUtil.js`

#### 核心功能

##### 1. 设置应用配置

```javascript
let appOptions = {
  router: undefined,
  i18n: undefined,
  store: undefined
}

/**
 * 设置应用配置
 * @param options {router, store, i18n}
 */
function setAppOptions(options) {
  const {router, store, i18n} = options
  appOptions.router = router
  appOptions.store = store
  appOptions.i18n = i18n
}
```

**作用**: 全局保存应用配置，供其他函数使用

##### 2. 动态路由重新渲染

```javascript
/**
 * 动态重新渲染菜单路由
 */
function setDynamicRouter() {
  const router = initRouter(true)          // 初始化集群模式路由
  const i18n = initI18n('CN', 'US')       // 初始化国际化
  bootstrap({router, store, i18n, message: Vue.prototype.$message})
}
```

**使用场景**: 
- 集群切换时重新加载路由
- 权限变更时刷新菜单

##### 3. 解析路由配置

```javascript
/**
 * 根据路由配置和路由组件注册解析路由
 * @param routesConfig 路由配置
 * @param routerMap 本地路由组件注册配置
 * @returns {Route[]}
 */
function parseRoutes(routesConfig, routerMap) {
  let routes = []
  
  routesConfig.forEach(item => {
    let router = undefined, routeCfg = {}
    
    // 支持字符串和对象两种配置方式
    if (typeof item === 'string') {
      router = routerMap[item]
      routeCfg = {
        path: (router && router.path) || item,
        router: item
      }
    } else if (typeof item === 'object') {
      router = routerMap[item.router]
      routeCfg = item
    }
    
    // 路由未注册警告
    if (!router) {
      console.warn(`can't find register for router ${routeCfg.router}`)
      router = typeof item === 'string' 
        ? {path: item, name: item} 
        : item
    }
    
    // 构建路由 meta
    const meta = {
      authority: router.authority,
      icon: router.icon,
      page: router.page,
      link: router.link,
      params: router.params,
      query: router.query,
      ...router.meta
    }
    
    // 合并配置 meta
    const cfgMeta = {
      authority: routeCfg.authority,
      icon: routeCfg.icon,
      page: routeCfg.page,
      link: routeCfg.link,
      params: routeCfg.params,
      query: routeCfg.query,
      ...routeCfg.meta
    }
    
    // 清理空值
    Object.keys(cfgMeta).forEach(key => {
      if (cfgMeta[key] === undefined || 
          cfgMeta[key] === null || 
          cfgMeta[key] === '') {
        delete cfgMeta[key]
      }
    })
    
    Object.assign(meta, cfgMeta)
    
    // 构建路由对象
    const route = {
      path: routeCfg.path || router.path || routeCfg.router,
      name: routeCfg.name || router.name,
      component: router.component,
      redirect: routeCfg.redirect || router.redirect,
      meta: {...meta, authority: meta.authority || '*'}
    }
    
    // 隐藏路由
    if (routeCfg.invisible || router.invisible) {
      route.meta.invisible = true
    }
    
    // 递归处理子路由
    if (routeCfg.children && routeCfg.children.length > 0) {
      route.children = parseRoutes(routeCfg.children, routerMap)
    }
    
    routes.push(route)
  })
  
  return routes
}
```

**特点**:
- 支持多种配置格式
- 自动合并路由 meta
- 递归处理子路由
- 灵活的权限配置

##### 4. 加载路由

```javascript
/**
 * 加载路由
 * @param routesConfig 路由配置
 * @param clusterRoutes 集群路由
 */
function loadRoutes(routesConfig, clusterRoutes) {
  const {store, i18n} = appOptions
  const router = clusterRoutes || appOptions.router
  
  // 保存或获取路由配置
  if (routesConfig) {
    store.commit('account/setRoutesConfig', routesConfig)
  } else {
    routesConfig = store.getters['account/routesConfig']
  }
  
  // 异步路由模式
  const asyncRoutes = store.state.setting.asyncRoutes
  if (asyncRoutes) {
    if (routesConfig && routesConfig.length > 0) {
      // 解析路由
      const routes = parseRoutes(routesConfig, routerMap)
      
      // 合并路由
      const finalRoutes = mergeRoutes(basicOptions.routes, routes)
      
      // 格式化路由
      formatRoutes(finalRoutes)
      
      // 更新路由
      router.options = {...router.options, routes: finalRoutes}
      router.matcher = new Router({...router.options, routes:[]}).matcher
      router.addRoutes(finalRoutes)
    }
  }
  
  // 提取路由国际化数据
  mergeI18nFromRoutes(i18n, router.options.routes)
  
  // 初始化菜单数据
  const rootRoute = router.options.routes.find(item => item.path === '/')
  const menuRoutes = rootRoute && rootRoute.children
  
  if (menuRoutes) {
    const isCluster = localStorage.getItem('isCluster')
    const menuData = localStorage.getItem('menuData') 
      ? JSON.parse(localStorage.getItem('menuData')) 
      : []
    
    if (isCluster === 'isCluster' && menuData) {
      // 集群模式
      store.dispatch('setting/getRunningClusterList')
      store.commit('setting/setIsCluster', isCluster)
    } else {
      // 全局模式
      store.commit('setting/setMenuData', menuRoutes)
      store.commit('setting/setIsCluster', '')
    }
  }
}
```

**流程**:
1. 获取或保存路由配置
2. 解析异步路由
3. 合并路由配置
4. 格式化路由
5. 动态添加路由
6. 提取国际化数据
7. 初始化菜单

##### 5. 格式化路由

```javascript
/**
 * 格式化路由
 * @param routes 路由配置
 */
function formatRoutes(routes) {
  routes.forEach(route => {
    const {path} = route
    // 确保路径以 / 开头
    if (!path.startsWith('/') && path !== '*') {
      route.path = '/' + path
    }
  })
  formatAuthority(routes)
}
```

##### 6. 格式化权限配置

```javascript
/**
 * 格式化路由的权限配置
 * @param routes 路由
 * @param pAuthorities 父级路由权限配置集合
 */
function formatAuthority(routes, pAuthorities = []) {
  routes.forEach(route => {
    const meta = route.meta
    const defaultAuthority = pAuthorities[pAuthorities.length - 1] 
      || {permission: '*'}
    
    if (meta) {
      let authority = {}
      
      if (!meta.authority) {
        // 没有配置权限，使用父级权限
        authority = defaultAuthority
      } else if (typeof meta.authority === 'string') {
        // 字符串形式权限
        authority.permission = meta.authority
      } else if (typeof meta.authority === 'object') {
        // 对象形式权限
        authority = meta.authority
        const {role} = authority
        if (typeof role === 'string') {
          authority.role = [role]
        }
        if (!authority.permission && !authority.role) {
          authority = defaultAuthority
        }
      }
      
      meta.authority = authority
    } else {
      // 没有 meta，创建默认权限
      const authority = defaultAuthority
      route.meta = {authority}
    }
    
    // 保存父级权限链
    route.meta.pAuthorities = pAuthorities
    
    // 递归处理子路由
    if (route.children) {
      formatAuthority(route.children, [...pAuthorities, route.meta.authority])
    }
  })
}
```

**特点**:
- 权限继承机制
- 支持多种权限格式
- 保存权限链用于追溯

##### 7. 加载路由守卫

```javascript
/**
 * 加载导航守卫
 * @param guards 守卫配置
 * @param options 选项 {router, store, message}
 */
function loadGuards(guards, options) {
  const {beforeEach, afterEach} = guards
  const {router} = options
  
  // 注册 beforeEach 守卫
  beforeEach.forEach(guard => {
    if (guard && typeof guard === 'function') {
      router.beforeEach((to, from, next) => 
        guard(to, from, next, options)
      )
    }
  })
  
  // 注册 afterEach 守卫
  afterEach.forEach(guard => {
    if (guard && typeof guard === 'function') {
      router.afterEach((to, from) => 
        guard(to, from, options)
      )
    }
  })
}
```

## 四、路由模式对比

### 4.1 全局模式 (config.js)

**特点**:
- 显示所有功能菜单
- 用于管理多个集群
- 不依赖特定集群上下文

**菜单结构**:
```
├── 总览
├── 集群管理
│   ├── 集群列表
│   ├── 存储库管理
│   └── 集群框架
├── 用户管理
└── 系统管理
    ├── 租户管理
    ├── 机架管理
    └── 标签管理
```

### 4.2 集群模式 (config-cluster.js)

**特点**:
- 显示集群相关菜单
- 聚焦单个集群操作
- 动态服务菜单

**菜单结构**:
```
├── 总览
├── 服务管理 (动态)
│   ├── HDFS
│   ├── YARN
│   ├── Spark
│   └── ...
├── 主机管理
├── 告警管理
│   ├── 告警组管理
│   └── 告警指标管理
└── 系统管理
```

## 五、路由懒加载

### 5.1 组件懒加载

```javascript
// 使用 import() 函数
component: () => import('@/pages/overview/index')

// 等同于
component: () => {
  return import('@/pages/overview/index')
}
```

**优点**:
- 按需加载，减小初始包体积
- 加快首屏加载速度
- Webpack 自动代码分割

### 5.2 路由分组加载

```javascript
// 同一组的组件会打包到一个 chunk 中
component: () => import(
  /* webpackChunkName: "service" */
  '@/pages/serviceManage/index'
)
```

**命名规则**:
```javascript
// chunk-service.js - 服务管理相关
// chunk-cluster.js - 集群管理相关
// chunk-host.js - 主机管理相关
```

## 六、路由权限控制

### 6.1 权限配置方式

#### 1. 通配符权限

```javascript
meta: {
  authority: '*'  // 所有人都可以访问
}
```

#### 2. 字符串权限

```javascript
meta: {
  authority: 'cluster:create'  // 需要特定权限
}
```

#### 3. 对象权限

```javascript
meta: {
  authority: {
    permission: 'cluster:create',  // 权限
    role: ['admin', 'operator']    // 或角色
  }
}
```

### 6.2 权限检查流程

```
用户访问路由
    ↓
白名单检查
    ↓
登录状态检查
    ↓
权限配置读取
    ↓
权限匹配检查
    ├─ 通过 → 允许访问
    └─ 失败 → 跳转 403
```

### 6.3 权限继承

```javascript
// 父路由权限
{
  path: '/admin',
  meta: {
    authority: 'admin:access'
  },
  children: [
    {
      path: 'users',
      // 未配置权限，继承父路由权限
      meta: {}
    },
    {
      path: 'settings',
      // 配置了新权限，覆盖父路由权限
      meta: {
        authority: 'admin:settings'
      }
    }
  ]
}
```

## 七、路由缓存控制

### 7.1 keep-alive 配置

```javascript
meta: {
  notAlive: true   // 不缓存页面
}
```

**使用场景**:
- `notAlive: true`: 数据频繁变化的页面（总览、监控）
- `notAlive: false`: 表单、列表页面

### 7.2 缓存实现

```vue
<!-- TabsView.vue -->
<template>
  <keep-alive :include="cachedPages">
    <router-view />
  </keep-alive>
</template>

<script>
computed: {
  cachedPages() {
    // 获取需要缓存的页面名称列表
    return this.$route.meta.notAlive 
      ? [] 
      : [this.$route.name]
  }
}
</script>
```

## 八、动态菜单生成

### 8.1 菜单数据结构

```javascript
{
  path: '/service-manage',
  name: '服务管理',
  meta: {
    icon: 'service-manage',
    isCluster: 'isCluster'
  },
  children: [
    {
      path: 'service-list/1',
      name: 'HDFS',
      meta: { serviceId: 1 }
    },
    {
      path: 'service-list/2',
      name: 'YARN',
      meta: { serviceId: 2 }
    }
  ]
}
```

### 8.2 菜单生成流程

```
1. 用户选择集群
   ↓
2. 获取集群服务列表
   ↓
3. 生成服务菜单
   ↓
4. 保存到 localStorage
   ↓
5. 更新 Vuex store
   ↓
6. 重新渲染菜单
```

## 九、路由导航方式

### 9.1 声明式导航

```vue
<!-- router-link -->
<router-link to="/overview">总览</router-link>

<!-- 命名路由 -->
<router-link :to="{ name: 'overview' }">总览</router-link>

<!-- 带参数 -->
<router-link :to="{ name: 'service', params: { serviceId: 1 } }">
  HDFS
</router-link>

<!-- 带查询参数 -->
<router-link :to="{ path: '/overview', query: { clusterId: 1 } }">
  总览
</router-link>
```

### 9.2 编程式导航

```javascript
// 字符串路径
this.$router.push('/overview')

// 对象
this.$router.push({ path: '/overview' })

// 命名路由
this.$router.push({ name: 'overview' })

// 带参数
this.$router.push({
  name: 'service',
  params: { serviceId: 1 }
})

// 带查询参数
this.$router.push({
  path: '/overview',
  query: { clusterId: 1 }
})

// replace (不产生历史记录)
this.$router.replace({ path: '/overview' })

// go (前进/后退)
this.$router.go(-1)  // 后退
this.$router.go(1)   // 前进
```

## 十、路由生命周期钩子

### 10.1 全局钩子

```javascript
// beforeEach
router.beforeEach((to, from, next) => {
  // 路由跳转前执行
  next()
})

// afterEach
router.afterEach((to, from) => {
  // 路由跳转后执行
})
```

### 10.2 路由独享钩子

```javascript
{
  path: '/overview',
  component: Overview,
  beforeEnter: (to, from, next) => {
    // 进入该路由前执行
    next()
  }
}
```

### 10.3 组件内钩子

```javascript
export default {
  beforeRouteEnter(to, from, next) {
    // 渲染该组件的路由被确认前调用
    // 不能访问 this
    next(vm => {
      // 通过 vm 访问组件实例
    })
  },
  
  beforeRouteUpdate(to, from, next) {
    // 路由改变，组件被复用时调用
    // 可以访问 this
    next()
  },
  
  beforeRouteLeave(to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问 this
    next()
  }
}
```

## 十一、最佳实践

### 11.1 路由命名规范

```javascript
// ✅ 推荐
{ name: 'clusterList', path: '/cluster/list' }
{ name: 'serviceDetail', path: '/service/:id' }

// ❌ 避免
{ name: 'list', path: '/cluster/list' }  // 名称不明确
{ name: '集群列表', path: '/cluster/list' }  // 使用中文
```

### 11.2 路由参数使用

```javascript
// ✅ 使用命名路由传参
this.$router.push({
  name: 'serviceDetail',
  params: { id: 1 }
})

// ❌ 避免拼接 URL
this.$router.push(`/service/${id}`)
```

### 11.3 路由懒加载分组

```javascript
// ✅ 按功能模块分组
component: () => import(
  /* webpackChunkName: "cluster" */
  '@/pages/colonyManage/list'
)

// ✅ 相关页面使用相同 chunk
component: () => import(
  /* webpackChunkName: "cluster" */
  '@/pages/colonyManage/detail'
)
```

### 11.4 路由元信息使用

```javascript
// ✅ 清晰的元信息
meta: {
  title: '集群管理',
  icon: 'cluster',
  requireAuth: true,
  keepAlive: false
}

// ❌ 混乱的元信息
meta: {
  a: true,
  b: 'cluster',
  c: false
}
```

## 十二、常见问题

### 12.1 路由跳转后页面不刷新

**原因**: 组件被复用，路由参数变化但组件未重新渲染

**解决方案**:
```javascript
// 方案 1: 监听 $route
watch: {
  '$route'(to, from) {
    this.loadData()
  }
}

// 方案 2: 使用 beforeRouteUpdate
beforeRouteUpdate(to, from, next) {
  this.loadData()
  next()
}

// 方案 3: 使用 :key
<router-view :key="$route.fullPath" />
```

### 12.2 动态添加路由后 404

**原因**: 404 路由 `path: '*'` 匹配所有路径，需要最后添加

**解决方案**:
```javascript
// ✅ 先添加其他路由，最后添加 404
router.addRoutes(dynamicRoutes)
router.addRoute({ path: '*', component: NotFound })

// ❌ 404 已存在，后续路由无效
router.addRoute({ path: '*', component: NotFound })
router.addRoutes(dynamicRoutes)
```

### 12.3 权限变更后菜单未更新

**解决方案**:
```javascript
// 重新加载路由和菜单
loadRoutes(newRoutesConfig)
location.reload()  // 或使用动态路由更新
```

## 十三、总结

### 核心特性

| 特性 | 说明 |
|------|------|
| 动态路由 | 支持运行时动态加载路由配置 |
| 权限控制 | 基于角色和权限的细粒度控制 |
| 路由守卫 | 多层守卫保障系统安全 |
| 懒加载 | 按需加载，优化性能 |
| 缓存控制 | 灵活的页面缓存策略 |
| 双模式 | 全局模式和集群模式切换 |

### 技术亮点

1. **灵活的权限系统**: 支持权限继承和多种配置方式
2. **动态菜单生成**: 根据集群服务动态生成菜单
3. **路由懒加载**: 提升首屏加载性能
4. **多守卫机制**: 登录、权限、重定向等多层防护
5. **双模式切换**: 全局管理和集群管理无缝切换

---

**文档状态**: ✅ 已完成  
**路由文件覆盖**: index.js, config.js, guards.js, routerUtil.js  
**最后更新**: 2025-11-16
